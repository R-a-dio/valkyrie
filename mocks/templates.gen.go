// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/R-a-dio/valkyrie/templates"
	"io"
	"net/http"
	"sync"
)

// Ensure, that ExecutorMock does implement templates.Executor.
// If this is not the case, regenerate this file with moq.
var _ templates.Executor = &ExecutorMock{}

// ExecutorMock is a mock implementation of templates.Executor.
//
//	func TestSomethingThatUsesExecutor(t *testing.T) {
//
//		// make and configure a mocked templates.Executor
//		mockedExecutor := &ExecutorMock{
//			ExecuteFunc: func(w io.Writer, r *http.Request, input templates.TemplateSelectable) error {
//				panic("mock out the Execute method")
//			},
//			ExecuteTemplateFunc: func(theme string, page string, template string, output io.Writer, input any) error {
//				panic("mock out the ExecuteTemplate method")
//			},
//			ExecuteTemplateAllFunc: func(template string, input any) (map[string][]byte, error) {
//				panic("mock out the ExecuteTemplateAll method")
//			},
//			WithFunc: func(contextMoqParam context.Context) templates.Executor {
//				panic("mock out the With method")
//			},
//		}
//
//		// use mockedExecutor in code that requires templates.Executor
//		// and then make assertions.
//
//	}
type ExecutorMock struct {
	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(w io.Writer, r *http.Request, input templates.TemplateSelectable) error

	// ExecuteTemplateFunc mocks the ExecuteTemplate method.
	ExecuteTemplateFunc func(theme string, page string, template string, output io.Writer, input any) error

	// ExecuteTemplateAllFunc mocks the ExecuteTemplateAll method.
	ExecuteTemplateAllFunc func(template string, input any) (map[string][]byte, error)

	// WithFunc mocks the With method.
	WithFunc func(contextMoqParam context.Context) templates.Executor

	// calls tracks calls to the methods.
	calls struct {
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// W is the w argument value.
			W io.Writer
			// R is the r argument value.
			R *http.Request
			// Input is the input argument value.
			Input templates.TemplateSelectable
		}
		// ExecuteTemplate holds details about calls to the ExecuteTemplate method.
		ExecuteTemplate []struct {
			// Theme is the theme argument value.
			Theme string
			// Page is the page argument value.
			Page string
			// Template is the template argument value.
			Template string
			// Output is the output argument value.
			Output io.Writer
			// Input is the input argument value.
			Input any
		}
		// ExecuteTemplateAll holds details about calls to the ExecuteTemplateAll method.
		ExecuteTemplateAll []struct {
			// Template is the template argument value.
			Template string
			// Input is the input argument value.
			Input any
		}
		// With holds details about calls to the With method.
		With []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockExecute            sync.RWMutex
	lockExecuteTemplate    sync.RWMutex
	lockExecuteTemplateAll sync.RWMutex
	lockWith               sync.RWMutex
}

// Execute calls ExecuteFunc.
func (mock *ExecutorMock) Execute(w io.Writer, r *http.Request, input templates.TemplateSelectable) error {
	if mock.ExecuteFunc == nil {
		panic("ExecutorMock.ExecuteFunc: method is nil but Executor.Execute was just called")
	}
	callInfo := struct {
		W     io.Writer
		R     *http.Request
		Input templates.TemplateSelectable
	}{
		W:     w,
		R:     r,
		Input: input,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(w, r, input)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedExecutor.ExecuteCalls())
func (mock *ExecutorMock) ExecuteCalls() []struct {
	W     io.Writer
	R     *http.Request
	Input templates.TemplateSelectable
} {
	var calls []struct {
		W     io.Writer
		R     *http.Request
		Input templates.TemplateSelectable
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// ExecuteTemplate calls ExecuteTemplateFunc.
func (mock *ExecutorMock) ExecuteTemplate(theme string, page string, template string, output io.Writer, input any) error {
	if mock.ExecuteTemplateFunc == nil {
		panic("ExecutorMock.ExecuteTemplateFunc: method is nil but Executor.ExecuteTemplate was just called")
	}
	callInfo := struct {
		Theme    string
		Page     string
		Template string
		Output   io.Writer
		Input    any
	}{
		Theme:    theme,
		Page:     page,
		Template: template,
		Output:   output,
		Input:    input,
	}
	mock.lockExecuteTemplate.Lock()
	mock.calls.ExecuteTemplate = append(mock.calls.ExecuteTemplate, callInfo)
	mock.lockExecuteTemplate.Unlock()
	return mock.ExecuteTemplateFunc(theme, page, template, output, input)
}

// ExecuteTemplateCalls gets all the calls that were made to ExecuteTemplate.
// Check the length with:
//
//	len(mockedExecutor.ExecuteTemplateCalls())
func (mock *ExecutorMock) ExecuteTemplateCalls() []struct {
	Theme    string
	Page     string
	Template string
	Output   io.Writer
	Input    any
} {
	var calls []struct {
		Theme    string
		Page     string
		Template string
		Output   io.Writer
		Input    any
	}
	mock.lockExecuteTemplate.RLock()
	calls = mock.calls.ExecuteTemplate
	mock.lockExecuteTemplate.RUnlock()
	return calls
}

// ExecuteTemplateAll calls ExecuteTemplateAllFunc.
func (mock *ExecutorMock) ExecuteTemplateAll(template string, input any) (map[string][]byte, error) {
	if mock.ExecuteTemplateAllFunc == nil {
		panic("ExecutorMock.ExecuteTemplateAllFunc: method is nil but Executor.ExecuteTemplateAll was just called")
	}
	callInfo := struct {
		Template string
		Input    any
	}{
		Template: template,
		Input:    input,
	}
	mock.lockExecuteTemplateAll.Lock()
	mock.calls.ExecuteTemplateAll = append(mock.calls.ExecuteTemplateAll, callInfo)
	mock.lockExecuteTemplateAll.Unlock()
	return mock.ExecuteTemplateAllFunc(template, input)
}

// ExecuteTemplateAllCalls gets all the calls that were made to ExecuteTemplateAll.
// Check the length with:
//
//	len(mockedExecutor.ExecuteTemplateAllCalls())
func (mock *ExecutorMock) ExecuteTemplateAllCalls() []struct {
	Template string
	Input    any
} {
	var calls []struct {
		Template string
		Input    any
	}
	mock.lockExecuteTemplateAll.RLock()
	calls = mock.calls.ExecuteTemplateAll
	mock.lockExecuteTemplateAll.RUnlock()
	return calls
}

// With calls WithFunc.
func (mock *ExecutorMock) With(contextMoqParam context.Context) templates.Executor {
	if mock.WithFunc == nil {
		panic("ExecutorMock.WithFunc: method is nil but Executor.With was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWith.Lock()
	mock.calls.With = append(mock.calls.With, callInfo)
	mock.lockWith.Unlock()
	return mock.WithFunc(contextMoqParam)
}

// WithCalls gets all the calls that were made to With.
// Check the length with:
//
//	len(mockedExecutor.WithCalls())
func (mock *ExecutorMock) WithCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWith.RLock()
	calls = mock.calls.With
	mock.lockWith.RUnlock()
	return calls
}
