// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/R-a-dio/valkyrie/templates"
	"io"
	"net/http"
	"sync"
)

// Ensure, that ExecutorMock does implement templates.Executor.
// If this is not the case, regenerate this file with moq.
var _ templates.Executor = &ExecutorMock{}

// ExecutorMock is a mock implementation of templates.Executor.
//
//	func TestSomethingThatUsesExecutor(t *testing.T) {
//
//		// make and configure a mocked templates.Executor
//		mockedExecutor := &ExecutorMock{
//			ExecuteFunc: func(w io.Writer, r *http.Request, input templates.TemplateSelectable) error {
//				panic("mock out the Execute method")
//			},
//			ExecuteAllFunc: func(input templates.TemplateSelectable) (map[string][]byte, error) {
//				panic("mock out the ExecuteAll method")
//			},
//			ExecuteTemplateFunc: func(theme string, page string, template string, output io.Writer, input any) error {
//				panic("mock out the ExecuteTemplate method")
//			},
//			WithFunc: func(contextMoqParam context.Context) templates.Executor {
//				panic("mock out the With method")
//			},
//		}
//
//		// use mockedExecutor in code that requires templates.Executor
//		// and then make assertions.
//
//	}
type ExecutorMock struct {
	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(w io.Writer, r *http.Request, input templates.TemplateSelectable) error

	// ExecuteAllFunc mocks the ExecuteAll method.
	ExecuteAllFunc func(input templates.TemplateSelectable) (map[string][]byte, error)

	// ExecuteTemplateFunc mocks the ExecuteTemplate method.
	ExecuteTemplateFunc func(theme string, page string, template string, output io.Writer, input any) error

	// WithFunc mocks the With method.
	WithFunc func(contextMoqParam context.Context) templates.Executor

	// calls tracks calls to the methods.
	calls struct {
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// W is the w argument value.
			W io.Writer
			// R is the r argument value.
			R *http.Request
			// Input is the input argument value.
			Input templates.TemplateSelectable
		}
		// ExecuteAll holds details about calls to the ExecuteAll method.
		ExecuteAll []struct {
			// Input is the input argument value.
			Input templates.TemplateSelectable
		}
		// ExecuteTemplate holds details about calls to the ExecuteTemplate method.
		ExecuteTemplate []struct {
			// Theme is the theme argument value.
			Theme string
			// Page is the page argument value.
			Page string
			// Template is the template argument value.
			Template string
			// Output is the output argument value.
			Output io.Writer
			// Input is the input argument value.
			Input any
		}
		// With holds details about calls to the With method.
		With []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockExecute         sync.RWMutex
	lockExecuteAll      sync.RWMutex
	lockExecuteTemplate sync.RWMutex
	lockWith            sync.RWMutex
}

// Execute calls ExecuteFunc.
func (mock *ExecutorMock) Execute(w io.Writer, r *http.Request, input templates.TemplateSelectable) error {
	if mock.ExecuteFunc == nil {
		panic("ExecutorMock.ExecuteFunc: method is nil but Executor.Execute was just called")
	}
	callInfo := struct {
		W     io.Writer
		R     *http.Request
		Input templates.TemplateSelectable
	}{
		W:     w,
		R:     r,
		Input: input,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(w, r, input)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedExecutor.ExecuteCalls())
func (mock *ExecutorMock) ExecuteCalls() []struct {
	W     io.Writer
	R     *http.Request
	Input templates.TemplateSelectable
} {
	var calls []struct {
		W     io.Writer
		R     *http.Request
		Input templates.TemplateSelectable
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// ExecuteAll calls ExecuteAllFunc.
func (mock *ExecutorMock) ExecuteAll(input templates.TemplateSelectable) (map[string][]byte, error) {
	if mock.ExecuteAllFunc == nil {
		panic("ExecutorMock.ExecuteAllFunc: method is nil but Executor.ExecuteAll was just called")
	}
	callInfo := struct {
		Input templates.TemplateSelectable
	}{
		Input: input,
	}
	mock.lockExecuteAll.Lock()
	mock.calls.ExecuteAll = append(mock.calls.ExecuteAll, callInfo)
	mock.lockExecuteAll.Unlock()
	return mock.ExecuteAllFunc(input)
}

// ExecuteAllCalls gets all the calls that were made to ExecuteAll.
// Check the length with:
//
//	len(mockedExecutor.ExecuteAllCalls())
func (mock *ExecutorMock) ExecuteAllCalls() []struct {
	Input templates.TemplateSelectable
} {
	var calls []struct {
		Input templates.TemplateSelectable
	}
	mock.lockExecuteAll.RLock()
	calls = mock.calls.ExecuteAll
	mock.lockExecuteAll.RUnlock()
	return calls
}

// ExecuteTemplate calls ExecuteTemplateFunc.
func (mock *ExecutorMock) ExecuteTemplate(theme string, page string, template string, output io.Writer, input any) error {
	if mock.ExecuteTemplateFunc == nil {
		panic("ExecutorMock.ExecuteTemplateFunc: method is nil but Executor.ExecuteTemplate was just called")
	}
	callInfo := struct {
		Theme    string
		Page     string
		Template string
		Output   io.Writer
		Input    any
	}{
		Theme:    theme,
		Page:     page,
		Template: template,
		Output:   output,
		Input:    input,
	}
	mock.lockExecuteTemplate.Lock()
	mock.calls.ExecuteTemplate = append(mock.calls.ExecuteTemplate, callInfo)
	mock.lockExecuteTemplate.Unlock()
	return mock.ExecuteTemplateFunc(theme, page, template, output, input)
}

// ExecuteTemplateCalls gets all the calls that were made to ExecuteTemplate.
// Check the length with:
//
//	len(mockedExecutor.ExecuteTemplateCalls())
func (mock *ExecutorMock) ExecuteTemplateCalls() []struct {
	Theme    string
	Page     string
	Template string
	Output   io.Writer
	Input    any
} {
	var calls []struct {
		Theme    string
		Page     string
		Template string
		Output   io.Writer
		Input    any
	}
	mock.lockExecuteTemplate.RLock()
	calls = mock.calls.ExecuteTemplate
	mock.lockExecuteTemplate.RUnlock()
	return calls
}

// With calls WithFunc.
func (mock *ExecutorMock) With(contextMoqParam context.Context) templates.Executor {
	if mock.WithFunc == nil {
		panic("ExecutorMock.WithFunc: method is nil but Executor.With was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWith.Lock()
	mock.calls.With = append(mock.calls.With, callInfo)
	mock.lockWith.Unlock()
	return mock.WithFunc(contextMoqParam)
}

// WithCalls gets all the calls that were made to With.
// Check the length with:
//
//	len(mockedExecutor.WithCalls())
func (mock *ExecutorMock) WithCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWith.RLock()
	calls = mock.calls.With
	mock.lockWith.RUnlock()
	return calls
}

// Ensure, that TemplateSelectableMock does implement templates.TemplateSelectable.
// If this is not the case, regenerate this file with moq.
var _ templates.TemplateSelectable = &TemplateSelectableMock{}

// TemplateSelectableMock is a mock implementation of templates.TemplateSelectable.
//
//	func TestSomethingThatUsesTemplateSelectable(t *testing.T) {
//
//		// make and configure a mocked templates.TemplateSelectable
//		mockedTemplateSelectable := &TemplateSelectableMock{
//			TemplateBundleFunc: func() string {
//				panic("mock out the TemplateBundle method")
//			},
//			TemplateNameFunc: func() string {
//				panic("mock out the TemplateName method")
//			},
//		}
//
//		// use mockedTemplateSelectable in code that requires templates.TemplateSelectable
//		// and then make assertions.
//
//	}
type TemplateSelectableMock struct {
	// TemplateBundleFunc mocks the TemplateBundle method.
	TemplateBundleFunc func() string

	// TemplateNameFunc mocks the TemplateName method.
	TemplateNameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// TemplateBundle holds details about calls to the TemplateBundle method.
		TemplateBundle []struct {
		}
		// TemplateName holds details about calls to the TemplateName method.
		TemplateName []struct {
		}
	}
	lockTemplateBundle sync.RWMutex
	lockTemplateName   sync.RWMutex
}

// TemplateBundle calls TemplateBundleFunc.
func (mock *TemplateSelectableMock) TemplateBundle() string {
	if mock.TemplateBundleFunc == nil {
		panic("TemplateSelectableMock.TemplateBundleFunc: method is nil but TemplateSelectable.TemplateBundle was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTemplateBundle.Lock()
	mock.calls.TemplateBundle = append(mock.calls.TemplateBundle, callInfo)
	mock.lockTemplateBundle.Unlock()
	return mock.TemplateBundleFunc()
}

// TemplateBundleCalls gets all the calls that were made to TemplateBundle.
// Check the length with:
//
//	len(mockedTemplateSelectable.TemplateBundleCalls())
func (mock *TemplateSelectableMock) TemplateBundleCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTemplateBundle.RLock()
	calls = mock.calls.TemplateBundle
	mock.lockTemplateBundle.RUnlock()
	return calls
}

// TemplateName calls TemplateNameFunc.
func (mock *TemplateSelectableMock) TemplateName() string {
	if mock.TemplateNameFunc == nil {
		panic("TemplateSelectableMock.TemplateNameFunc: method is nil but TemplateSelectable.TemplateName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTemplateName.Lock()
	mock.calls.TemplateName = append(mock.calls.TemplateName, callInfo)
	mock.lockTemplateName.Unlock()
	return mock.TemplateNameFunc()
}

// TemplateNameCalls gets all the calls that were made to TemplateName.
// Check the length with:
//
//	len(mockedTemplateSelectable.TemplateNameCalls())
func (mock *TemplateSelectableMock) TemplateNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTemplateName.RLock()
	calls = mock.calls.TemplateName
	mock.lockTemplateName.RUnlock()
	return calls
}
