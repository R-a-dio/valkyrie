// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/R-a-dio/valkyrie"
	"github.com/R-a-dio/valkyrie/util/eventstream"
	"sync"
	"time"
)

// Ensure, that StorageServiceMock does implement radio.StorageService.
// If this is not the case, regenerate this file with moq.
var _ radio.StorageService = &StorageServiceMock{}

// StorageServiceMock is a mock implementation of radio.StorageService.
//
//	func TestSomethingThatUsesStorageService(t *testing.T) {
//
//		// make and configure a mocked radio.StorageService
//		mockedStorageService := &StorageServiceMock{
//			NewsFunc: func(contextMoqParam context.Context) radio.NewsStorage {
//				panic("mock out the News method")
//			},
//			NewsTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.NewsStorage, radio.StorageTx, error) {
//				panic("mock out the NewsTx method")
//			},
//			QueueFunc: func(contextMoqParam context.Context) radio.QueueStorage {
//				panic("mock out the Queue method")
//			},
//			QueueTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.QueueStorage, radio.StorageTx, error) {
//				panic("mock out the QueueTx method")
//			},
//			RelayFunc: func(contextMoqParam context.Context) radio.RelayStorage {
//				panic("mock out the Relay method")
//			},
//			RelayTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RelayStorage, radio.StorageTx, error) {
//				panic("mock out the RelayTx method")
//			},
//			RequestFunc: func(contextMoqParam context.Context) radio.RequestStorage {
//				panic("mock out the Request method")
//			},
//			RequestTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RequestStorage, radio.StorageTx, error) {
//				panic("mock out the RequestTx method")
//			},
//			ScheduleFunc: func(contextMoqParam context.Context) radio.ScheduleStorage {
//				panic("mock out the Schedule method")
//			},
//			ScheduleTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.ScheduleStorage, radio.StorageTx, error) {
//				panic("mock out the ScheduleTx method")
//			},
//			SessionsFunc: func(contextMoqParam context.Context) radio.SessionStorage {
//				panic("mock out the Sessions method")
//			},
//			SessionsTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SessionStorage, radio.StorageTx, error) {
//				panic("mock out the SessionsTx method")
//			},
//			SongFunc: func(contextMoqParam context.Context) radio.SongStorage {
//				panic("mock out the Song method")
//			},
//			SongTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SongStorage, radio.StorageTx, error) {
//				panic("mock out the SongTx method")
//			},
//			StatusFunc: func(contextMoqParam context.Context) radio.StatusStorage {
//				panic("mock out the Status method")
//			},
//			SubmissionsFunc: func(contextMoqParam context.Context) radio.SubmissionStorage {
//				panic("mock out the Submissions method")
//			},
//			SubmissionsTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SubmissionStorage, radio.StorageTx, error) {
//				panic("mock out the SubmissionsTx method")
//			},
//			TrackFunc: func(contextMoqParam context.Context) radio.TrackStorage {
//				panic("mock out the Track method")
//			},
//			TrackTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.TrackStorage, radio.StorageTx, error) {
//				panic("mock out the TrackTx method")
//			},
//			UserFunc: func(contextMoqParam context.Context) radio.UserStorage {
//				panic("mock out the User method")
//			},
//			UserTxFunc: func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.UserStorage, radio.StorageTx, error) {
//				panic("mock out the UserTx method")
//			},
//		}
//
//		// use mockedStorageService in code that requires radio.StorageService
//		// and then make assertions.
//
//	}
type StorageServiceMock struct {
	// NewsFunc mocks the News method.
	NewsFunc func(contextMoqParam context.Context) radio.NewsStorage

	// NewsTxFunc mocks the NewsTx method.
	NewsTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.NewsStorage, radio.StorageTx, error)

	// QueueFunc mocks the Queue method.
	QueueFunc func(contextMoqParam context.Context) radio.QueueStorage

	// QueueTxFunc mocks the QueueTx method.
	QueueTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.QueueStorage, radio.StorageTx, error)

	// RelayFunc mocks the Relay method.
	RelayFunc func(contextMoqParam context.Context) radio.RelayStorage

	// RelayTxFunc mocks the RelayTx method.
	RelayTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RelayStorage, radio.StorageTx, error)

	// RequestFunc mocks the Request method.
	RequestFunc func(contextMoqParam context.Context) radio.RequestStorage

	// RequestTxFunc mocks the RequestTx method.
	RequestTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RequestStorage, radio.StorageTx, error)

	// ScheduleFunc mocks the Schedule method.
	ScheduleFunc func(contextMoqParam context.Context) radio.ScheduleStorage

	// ScheduleTxFunc mocks the ScheduleTx method.
	ScheduleTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.ScheduleStorage, radio.StorageTx, error)

	// SessionsFunc mocks the Sessions method.
	SessionsFunc func(contextMoqParam context.Context) radio.SessionStorage

	// SessionsTxFunc mocks the SessionsTx method.
	SessionsTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SessionStorage, radio.StorageTx, error)

	// SongFunc mocks the Song method.
	SongFunc func(contextMoqParam context.Context) radio.SongStorage

	// SongTxFunc mocks the SongTx method.
	SongTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SongStorage, radio.StorageTx, error)

	// StatusFunc mocks the Status method.
	StatusFunc func(contextMoqParam context.Context) radio.StatusStorage

	// SubmissionsFunc mocks the Submissions method.
	SubmissionsFunc func(contextMoqParam context.Context) radio.SubmissionStorage

	// SubmissionsTxFunc mocks the SubmissionsTx method.
	SubmissionsTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SubmissionStorage, radio.StorageTx, error)

	// TrackFunc mocks the Track method.
	TrackFunc func(contextMoqParam context.Context) radio.TrackStorage

	// TrackTxFunc mocks the TrackTx method.
	TrackTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.TrackStorage, radio.StorageTx, error)

	// UserFunc mocks the User method.
	UserFunc func(contextMoqParam context.Context) radio.UserStorage

	// UserTxFunc mocks the UserTx method.
	UserTxFunc func(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.UserStorage, radio.StorageTx, error)

	// calls tracks calls to the methods.
	calls struct {
		// News holds details about calls to the News method.
		News []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// NewsTx holds details about calls to the NewsTx method.
		NewsTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Queue holds details about calls to the Queue method.
		Queue []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// QueueTx holds details about calls to the QueueTx method.
		QueueTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Relay holds details about calls to the Relay method.
		Relay []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// RelayTx holds details about calls to the RelayTx method.
		RelayTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Request holds details about calls to the Request method.
		Request []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// RequestTx holds details about calls to the RequestTx method.
		RequestTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Schedule holds details about calls to the Schedule method.
		Schedule []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// ScheduleTx holds details about calls to the ScheduleTx method.
		ScheduleTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Sessions holds details about calls to the Sessions method.
		Sessions []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SessionsTx holds details about calls to the SessionsTx method.
		SessionsTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Song holds details about calls to the Song method.
		Song []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SongTx holds details about calls to the SongTx method.
		SongTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Status holds details about calls to the Status method.
		Status []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Submissions holds details about calls to the Submissions method.
		Submissions []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SubmissionsTx holds details about calls to the SubmissionsTx method.
		SubmissionsTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// Track holds details about calls to the Track method.
		Track []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// TrackTx holds details about calls to the TrackTx method.
		TrackTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
		// User holds details about calls to the User method.
		User []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// UserTx holds details about calls to the UserTx method.
		UserTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StorageTx is the storageTx argument value.
			StorageTx radio.StorageTx
		}
	}
	lockNews          sync.RWMutex
	lockNewsTx        sync.RWMutex
	lockQueue         sync.RWMutex
	lockQueueTx       sync.RWMutex
	lockRelay         sync.RWMutex
	lockRelayTx       sync.RWMutex
	lockRequest       sync.RWMutex
	lockRequestTx     sync.RWMutex
	lockSchedule      sync.RWMutex
	lockScheduleTx    sync.RWMutex
	lockSessions      sync.RWMutex
	lockSessionsTx    sync.RWMutex
	lockSong          sync.RWMutex
	lockSongTx        sync.RWMutex
	lockStatus        sync.RWMutex
	lockSubmissions   sync.RWMutex
	lockSubmissionsTx sync.RWMutex
	lockTrack         sync.RWMutex
	lockTrackTx       sync.RWMutex
	lockUser          sync.RWMutex
	lockUserTx        sync.RWMutex
}

// News calls NewsFunc.
func (mock *StorageServiceMock) News(contextMoqParam context.Context) radio.NewsStorage {
	if mock.NewsFunc == nil {
		panic("StorageServiceMock.NewsFunc: method is nil but StorageService.News was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNews.Lock()
	mock.calls.News = append(mock.calls.News, callInfo)
	mock.lockNews.Unlock()
	return mock.NewsFunc(contextMoqParam)
}

// NewsCalls gets all the calls that were made to News.
// Check the length with:
//
//	len(mockedStorageService.NewsCalls())
func (mock *StorageServiceMock) NewsCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNews.RLock()
	calls = mock.calls.News
	mock.lockNews.RUnlock()
	return calls
}

// NewsTx calls NewsTxFunc.
func (mock *StorageServiceMock) NewsTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.NewsStorage, radio.StorageTx, error) {
	if mock.NewsTxFunc == nil {
		panic("StorageServiceMock.NewsTxFunc: method is nil but StorageService.NewsTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockNewsTx.Lock()
	mock.calls.NewsTx = append(mock.calls.NewsTx, callInfo)
	mock.lockNewsTx.Unlock()
	return mock.NewsTxFunc(contextMoqParam, storageTx)
}

// NewsTxCalls gets all the calls that were made to NewsTx.
// Check the length with:
//
//	len(mockedStorageService.NewsTxCalls())
func (mock *StorageServiceMock) NewsTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockNewsTx.RLock()
	calls = mock.calls.NewsTx
	mock.lockNewsTx.RUnlock()
	return calls
}

// Queue calls QueueFunc.
func (mock *StorageServiceMock) Queue(contextMoqParam context.Context) radio.QueueStorage {
	if mock.QueueFunc == nil {
		panic("StorageServiceMock.QueueFunc: method is nil but StorageService.Queue was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockQueue.Lock()
	mock.calls.Queue = append(mock.calls.Queue, callInfo)
	mock.lockQueue.Unlock()
	return mock.QueueFunc(contextMoqParam)
}

// QueueCalls gets all the calls that were made to Queue.
// Check the length with:
//
//	len(mockedStorageService.QueueCalls())
func (mock *StorageServiceMock) QueueCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockQueue.RLock()
	calls = mock.calls.Queue
	mock.lockQueue.RUnlock()
	return calls
}

// QueueTx calls QueueTxFunc.
func (mock *StorageServiceMock) QueueTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.QueueStorage, radio.StorageTx, error) {
	if mock.QueueTxFunc == nil {
		panic("StorageServiceMock.QueueTxFunc: method is nil but StorageService.QueueTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockQueueTx.Lock()
	mock.calls.QueueTx = append(mock.calls.QueueTx, callInfo)
	mock.lockQueueTx.Unlock()
	return mock.QueueTxFunc(contextMoqParam, storageTx)
}

// QueueTxCalls gets all the calls that were made to QueueTx.
// Check the length with:
//
//	len(mockedStorageService.QueueTxCalls())
func (mock *StorageServiceMock) QueueTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockQueueTx.RLock()
	calls = mock.calls.QueueTx
	mock.lockQueueTx.RUnlock()
	return calls
}

// Relay calls RelayFunc.
func (mock *StorageServiceMock) Relay(contextMoqParam context.Context) radio.RelayStorage {
	if mock.RelayFunc == nil {
		panic("StorageServiceMock.RelayFunc: method is nil but StorageService.Relay was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockRelay.Lock()
	mock.calls.Relay = append(mock.calls.Relay, callInfo)
	mock.lockRelay.Unlock()
	return mock.RelayFunc(contextMoqParam)
}

// RelayCalls gets all the calls that were made to Relay.
// Check the length with:
//
//	len(mockedStorageService.RelayCalls())
func (mock *StorageServiceMock) RelayCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockRelay.RLock()
	calls = mock.calls.Relay
	mock.lockRelay.RUnlock()
	return calls
}

// RelayTx calls RelayTxFunc.
func (mock *StorageServiceMock) RelayTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RelayStorage, radio.StorageTx, error) {
	if mock.RelayTxFunc == nil {
		panic("StorageServiceMock.RelayTxFunc: method is nil but StorageService.RelayTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockRelayTx.Lock()
	mock.calls.RelayTx = append(mock.calls.RelayTx, callInfo)
	mock.lockRelayTx.Unlock()
	return mock.RelayTxFunc(contextMoqParam, storageTx)
}

// RelayTxCalls gets all the calls that were made to RelayTx.
// Check the length with:
//
//	len(mockedStorageService.RelayTxCalls())
func (mock *StorageServiceMock) RelayTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockRelayTx.RLock()
	calls = mock.calls.RelayTx
	mock.lockRelayTx.RUnlock()
	return calls
}

// Request calls RequestFunc.
func (mock *StorageServiceMock) Request(contextMoqParam context.Context) radio.RequestStorage {
	if mock.RequestFunc == nil {
		panic("StorageServiceMock.RequestFunc: method is nil but StorageService.Request was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockRequest.Lock()
	mock.calls.Request = append(mock.calls.Request, callInfo)
	mock.lockRequest.Unlock()
	return mock.RequestFunc(contextMoqParam)
}

// RequestCalls gets all the calls that were made to Request.
// Check the length with:
//
//	len(mockedStorageService.RequestCalls())
func (mock *StorageServiceMock) RequestCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockRequest.RLock()
	calls = mock.calls.Request
	mock.lockRequest.RUnlock()
	return calls
}

// RequestTx calls RequestTxFunc.
func (mock *StorageServiceMock) RequestTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.RequestStorage, radio.StorageTx, error) {
	if mock.RequestTxFunc == nil {
		panic("StorageServiceMock.RequestTxFunc: method is nil but StorageService.RequestTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockRequestTx.Lock()
	mock.calls.RequestTx = append(mock.calls.RequestTx, callInfo)
	mock.lockRequestTx.Unlock()
	return mock.RequestTxFunc(contextMoqParam, storageTx)
}

// RequestTxCalls gets all the calls that were made to RequestTx.
// Check the length with:
//
//	len(mockedStorageService.RequestTxCalls())
func (mock *StorageServiceMock) RequestTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockRequestTx.RLock()
	calls = mock.calls.RequestTx
	mock.lockRequestTx.RUnlock()
	return calls
}

// Schedule calls ScheduleFunc.
func (mock *StorageServiceMock) Schedule(contextMoqParam context.Context) radio.ScheduleStorage {
	if mock.ScheduleFunc == nil {
		panic("StorageServiceMock.ScheduleFunc: method is nil but StorageService.Schedule was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockSchedule.Lock()
	mock.calls.Schedule = append(mock.calls.Schedule, callInfo)
	mock.lockSchedule.Unlock()
	return mock.ScheduleFunc(contextMoqParam)
}

// ScheduleCalls gets all the calls that were made to Schedule.
// Check the length with:
//
//	len(mockedStorageService.ScheduleCalls())
func (mock *StorageServiceMock) ScheduleCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockSchedule.RLock()
	calls = mock.calls.Schedule
	mock.lockSchedule.RUnlock()
	return calls
}

// ScheduleTx calls ScheduleTxFunc.
func (mock *StorageServiceMock) ScheduleTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.ScheduleStorage, radio.StorageTx, error) {
	if mock.ScheduleTxFunc == nil {
		panic("StorageServiceMock.ScheduleTxFunc: method is nil but StorageService.ScheduleTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockScheduleTx.Lock()
	mock.calls.ScheduleTx = append(mock.calls.ScheduleTx, callInfo)
	mock.lockScheduleTx.Unlock()
	return mock.ScheduleTxFunc(contextMoqParam, storageTx)
}

// ScheduleTxCalls gets all the calls that were made to ScheduleTx.
// Check the length with:
//
//	len(mockedStorageService.ScheduleTxCalls())
func (mock *StorageServiceMock) ScheduleTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockScheduleTx.RLock()
	calls = mock.calls.ScheduleTx
	mock.lockScheduleTx.RUnlock()
	return calls
}

// Sessions calls SessionsFunc.
func (mock *StorageServiceMock) Sessions(contextMoqParam context.Context) radio.SessionStorage {
	if mock.SessionsFunc == nil {
		panic("StorageServiceMock.SessionsFunc: method is nil but StorageService.Sessions was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockSessions.Lock()
	mock.calls.Sessions = append(mock.calls.Sessions, callInfo)
	mock.lockSessions.Unlock()
	return mock.SessionsFunc(contextMoqParam)
}

// SessionsCalls gets all the calls that were made to Sessions.
// Check the length with:
//
//	len(mockedStorageService.SessionsCalls())
func (mock *StorageServiceMock) SessionsCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockSessions.RLock()
	calls = mock.calls.Sessions
	mock.lockSessions.RUnlock()
	return calls
}

// SessionsTx calls SessionsTxFunc.
func (mock *StorageServiceMock) SessionsTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SessionStorage, radio.StorageTx, error) {
	if mock.SessionsTxFunc == nil {
		panic("StorageServiceMock.SessionsTxFunc: method is nil but StorageService.SessionsTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockSessionsTx.Lock()
	mock.calls.SessionsTx = append(mock.calls.SessionsTx, callInfo)
	mock.lockSessionsTx.Unlock()
	return mock.SessionsTxFunc(contextMoqParam, storageTx)
}

// SessionsTxCalls gets all the calls that were made to SessionsTx.
// Check the length with:
//
//	len(mockedStorageService.SessionsTxCalls())
func (mock *StorageServiceMock) SessionsTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockSessionsTx.RLock()
	calls = mock.calls.SessionsTx
	mock.lockSessionsTx.RUnlock()
	return calls
}

// Song calls SongFunc.
func (mock *StorageServiceMock) Song(contextMoqParam context.Context) radio.SongStorage {
	if mock.SongFunc == nil {
		panic("StorageServiceMock.SongFunc: method is nil but StorageService.Song was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockSong.Lock()
	mock.calls.Song = append(mock.calls.Song, callInfo)
	mock.lockSong.Unlock()
	return mock.SongFunc(contextMoqParam)
}

// SongCalls gets all the calls that were made to Song.
// Check the length with:
//
//	len(mockedStorageService.SongCalls())
func (mock *StorageServiceMock) SongCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockSong.RLock()
	calls = mock.calls.Song
	mock.lockSong.RUnlock()
	return calls
}

// SongTx calls SongTxFunc.
func (mock *StorageServiceMock) SongTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SongStorage, radio.StorageTx, error) {
	if mock.SongTxFunc == nil {
		panic("StorageServiceMock.SongTxFunc: method is nil but StorageService.SongTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockSongTx.Lock()
	mock.calls.SongTx = append(mock.calls.SongTx, callInfo)
	mock.lockSongTx.Unlock()
	return mock.SongTxFunc(contextMoqParam, storageTx)
}

// SongTxCalls gets all the calls that were made to SongTx.
// Check the length with:
//
//	len(mockedStorageService.SongTxCalls())
func (mock *StorageServiceMock) SongTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockSongTx.RLock()
	calls = mock.calls.SongTx
	mock.lockSongTx.RUnlock()
	return calls
}

// Status calls StatusFunc.
func (mock *StorageServiceMock) Status(contextMoqParam context.Context) radio.StatusStorage {
	if mock.StatusFunc == nil {
		panic("StorageServiceMock.StatusFunc: method is nil but StorageService.Status was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockStatus.Lock()
	mock.calls.Status = append(mock.calls.Status, callInfo)
	mock.lockStatus.Unlock()
	return mock.StatusFunc(contextMoqParam)
}

// StatusCalls gets all the calls that were made to Status.
// Check the length with:
//
//	len(mockedStorageService.StatusCalls())
func (mock *StorageServiceMock) StatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockStatus.RLock()
	calls = mock.calls.Status
	mock.lockStatus.RUnlock()
	return calls
}

// Submissions calls SubmissionsFunc.
func (mock *StorageServiceMock) Submissions(contextMoqParam context.Context) radio.SubmissionStorage {
	if mock.SubmissionsFunc == nil {
		panic("StorageServiceMock.SubmissionsFunc: method is nil but StorageService.Submissions was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockSubmissions.Lock()
	mock.calls.Submissions = append(mock.calls.Submissions, callInfo)
	mock.lockSubmissions.Unlock()
	return mock.SubmissionsFunc(contextMoqParam)
}

// SubmissionsCalls gets all the calls that were made to Submissions.
// Check the length with:
//
//	len(mockedStorageService.SubmissionsCalls())
func (mock *StorageServiceMock) SubmissionsCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockSubmissions.RLock()
	calls = mock.calls.Submissions
	mock.lockSubmissions.RUnlock()
	return calls
}

// SubmissionsTx calls SubmissionsTxFunc.
func (mock *StorageServiceMock) SubmissionsTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.SubmissionStorage, radio.StorageTx, error) {
	if mock.SubmissionsTxFunc == nil {
		panic("StorageServiceMock.SubmissionsTxFunc: method is nil but StorageService.SubmissionsTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockSubmissionsTx.Lock()
	mock.calls.SubmissionsTx = append(mock.calls.SubmissionsTx, callInfo)
	mock.lockSubmissionsTx.Unlock()
	return mock.SubmissionsTxFunc(contextMoqParam, storageTx)
}

// SubmissionsTxCalls gets all the calls that were made to SubmissionsTx.
// Check the length with:
//
//	len(mockedStorageService.SubmissionsTxCalls())
func (mock *StorageServiceMock) SubmissionsTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockSubmissionsTx.RLock()
	calls = mock.calls.SubmissionsTx
	mock.lockSubmissionsTx.RUnlock()
	return calls
}

// Track calls TrackFunc.
func (mock *StorageServiceMock) Track(contextMoqParam context.Context) radio.TrackStorage {
	if mock.TrackFunc == nil {
		panic("StorageServiceMock.TrackFunc: method is nil but StorageService.Track was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockTrack.Lock()
	mock.calls.Track = append(mock.calls.Track, callInfo)
	mock.lockTrack.Unlock()
	return mock.TrackFunc(contextMoqParam)
}

// TrackCalls gets all the calls that were made to Track.
// Check the length with:
//
//	len(mockedStorageService.TrackCalls())
func (mock *StorageServiceMock) TrackCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockTrack.RLock()
	calls = mock.calls.Track
	mock.lockTrack.RUnlock()
	return calls
}

// TrackTx calls TrackTxFunc.
func (mock *StorageServiceMock) TrackTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.TrackStorage, radio.StorageTx, error) {
	if mock.TrackTxFunc == nil {
		panic("StorageServiceMock.TrackTxFunc: method is nil but StorageService.TrackTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockTrackTx.Lock()
	mock.calls.TrackTx = append(mock.calls.TrackTx, callInfo)
	mock.lockTrackTx.Unlock()
	return mock.TrackTxFunc(contextMoqParam, storageTx)
}

// TrackTxCalls gets all the calls that were made to TrackTx.
// Check the length with:
//
//	len(mockedStorageService.TrackTxCalls())
func (mock *StorageServiceMock) TrackTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockTrackTx.RLock()
	calls = mock.calls.TrackTx
	mock.lockTrackTx.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *StorageServiceMock) User(contextMoqParam context.Context) radio.UserStorage {
	if mock.UserFunc == nil {
		panic("StorageServiceMock.UserFunc: method is nil but StorageService.User was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc(contextMoqParam)
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedStorageService.UserCalls())
func (mock *StorageServiceMock) UserCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// UserTx calls UserTxFunc.
func (mock *StorageServiceMock) UserTx(contextMoqParam context.Context, storageTx radio.StorageTx) (radio.UserStorage, radio.StorageTx, error) {
	if mock.UserTxFunc == nil {
		panic("StorageServiceMock.UserTxFunc: method is nil but StorageService.UserTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}{
		ContextMoqParam: contextMoqParam,
		StorageTx:       storageTx,
	}
	mock.lockUserTx.Lock()
	mock.calls.UserTx = append(mock.calls.UserTx, callInfo)
	mock.lockUserTx.Unlock()
	return mock.UserTxFunc(contextMoqParam, storageTx)
}

// UserTxCalls gets all the calls that were made to UserTx.
// Check the length with:
//
//	len(mockedStorageService.UserTxCalls())
func (mock *StorageServiceMock) UserTxCalls() []struct {
	ContextMoqParam context.Context
	StorageTx       radio.StorageTx
} {
	var calls []struct {
		ContextMoqParam context.Context
		StorageTx       radio.StorageTx
	}
	mock.lockUserTx.RLock()
	calls = mock.calls.UserTx
	mock.lockUserTx.RUnlock()
	return calls
}

// Ensure, that StorageTxMock does implement radio.StorageTx.
// If this is not the case, regenerate this file with moq.
var _ radio.StorageTx = &StorageTxMock{}

// StorageTxMock is a mock implementation of radio.StorageTx.
//
//	func TestSomethingThatUsesStorageTx(t *testing.T) {
//
//		// make and configure a mocked radio.StorageTx
//		mockedStorageTx := &StorageTxMock{
//			CommitFunc: func() error {
//				panic("mock out the Commit method")
//			},
//			RollbackFunc: func() error {
//				panic("mock out the Rollback method")
//			},
//		}
//
//		// use mockedStorageTx in code that requires radio.StorageTx
//		// and then make assertions.
//
//	}
type StorageTxMock struct {
	// CommitFunc mocks the Commit method.
	CommitFunc func() error

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
		}
	}
	lockCommit   sync.RWMutex
	lockRollback sync.RWMutex
}

// Commit calls CommitFunc.
func (mock *StorageTxMock) Commit() error {
	if mock.CommitFunc == nil {
		panic("StorageTxMock.CommitFunc: method is nil but StorageTx.Commit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedStorageTx.CommitCalls())
func (mock *StorageTxMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *StorageTxMock) Rollback() error {
	if mock.RollbackFunc == nil {
		panic("StorageTxMock.RollbackFunc: method is nil but StorageTx.Rollback was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc()
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//
//	len(mockedStorageTx.RollbackCalls())
func (mock *StorageTxMock) RollbackCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// Ensure, that TrackStorageMock does implement radio.TrackStorage.
// If this is not the case, regenerate this file with moq.
var _ radio.TrackStorage = &TrackStorageMock{}

// TrackStorageMock is a mock implementation of radio.TrackStorage.
//
//	func TestSomethingThatUsesTrackStorage(t *testing.T) {
//
//		// make and configure a mocked radio.TrackStorage
//		mockedTrackStorage := &TrackStorageMock{
//			AllFunc: func() ([]radio.Song, error) {
//				panic("mock out the All method")
//			},
//			BeforeLastRequestedFunc: func(before time.Time) ([]radio.Song, error) {
//				panic("mock out the BeforeLastRequested method")
//			},
//			DecrementRequestCountFunc: func(before time.Time) error {
//				panic("mock out the DecrementRequestCount method")
//			},
//			DeleteFunc: func(trackID radio.TrackID) error {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(trackID radio.TrackID) (*radio.Song, error) {
//				panic("mock out the Get method")
//			},
//			InsertFunc: func(song radio.Song) (radio.TrackID, error) {
//				panic("mock out the Insert method")
//			},
//			QueueCandidatesFunc: func() ([]radio.TrackID, error) {
//				panic("mock out the QueueCandidates method")
//			},
//			UnusableFunc: func() ([]radio.Song, error) {
//				panic("mock out the Unusable method")
//			},
//			UpdateLastPlayedFunc: func(trackID radio.TrackID) error {
//				panic("mock out the UpdateLastPlayed method")
//			},
//			UpdateLastRequestedFunc: func(trackID radio.TrackID) error {
//				panic("mock out the UpdateLastRequested method")
//			},
//			UpdateMetadataFunc: func(song radio.Song) error {
//				panic("mock out the UpdateMetadata method")
//			},
//			UpdateRequestInfoFunc: func(trackID radio.TrackID) error {
//				panic("mock out the UpdateRequestInfo method")
//			},
//			UpdateUsableFunc: func(song radio.Song, state radio.TrackState) error {
//				panic("mock out the UpdateUsable method")
//			},
//		}
//
//		// use mockedTrackStorage in code that requires radio.TrackStorage
//		// and then make assertions.
//
//	}
type TrackStorageMock struct {
	// AllFunc mocks the All method.
	AllFunc func() ([]radio.Song, error)

	// BeforeLastRequestedFunc mocks the BeforeLastRequested method.
	BeforeLastRequestedFunc func(before time.Time) ([]radio.Song, error)

	// DecrementRequestCountFunc mocks the DecrementRequestCount method.
	DecrementRequestCountFunc func(before time.Time) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(trackID radio.TrackID) error

	// GetFunc mocks the Get method.
	GetFunc func(trackID radio.TrackID) (*radio.Song, error)

	// InsertFunc mocks the Insert method.
	InsertFunc func(song radio.Song) (radio.TrackID, error)

	// QueueCandidatesFunc mocks the QueueCandidates method.
	QueueCandidatesFunc func() ([]radio.TrackID, error)

	// UnusableFunc mocks the Unusable method.
	UnusableFunc func() ([]radio.Song, error)

	// UpdateLastPlayedFunc mocks the UpdateLastPlayed method.
	UpdateLastPlayedFunc func(trackID radio.TrackID) error

	// UpdateLastRequestedFunc mocks the UpdateLastRequested method.
	UpdateLastRequestedFunc func(trackID radio.TrackID) error

	// UpdateMetadataFunc mocks the UpdateMetadata method.
	UpdateMetadataFunc func(song radio.Song) error

	// UpdateRequestInfoFunc mocks the UpdateRequestInfo method.
	UpdateRequestInfoFunc func(trackID radio.TrackID) error

	// UpdateUsableFunc mocks the UpdateUsable method.
	UpdateUsableFunc func(song radio.Song, state radio.TrackState) error

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// BeforeLastRequested holds details about calls to the BeforeLastRequested method.
		BeforeLastRequested []struct {
			// Before is the before argument value.
			Before time.Time
		}
		// DecrementRequestCount holds details about calls to the DecrementRequestCount method.
		DecrementRequestCount []struct {
			// Before is the before argument value.
			Before time.Time
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// TrackID is the trackID argument value.
			TrackID radio.TrackID
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// TrackID is the trackID argument value.
			TrackID radio.TrackID
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Song is the song argument value.
			Song radio.Song
		}
		// QueueCandidates holds details about calls to the QueueCandidates method.
		QueueCandidates []struct {
		}
		// Unusable holds details about calls to the Unusable method.
		Unusable []struct {
		}
		// UpdateLastPlayed holds details about calls to the UpdateLastPlayed method.
		UpdateLastPlayed []struct {
			// TrackID is the trackID argument value.
			TrackID radio.TrackID
		}
		// UpdateLastRequested holds details about calls to the UpdateLastRequested method.
		UpdateLastRequested []struct {
			// TrackID is the trackID argument value.
			TrackID radio.TrackID
		}
		// UpdateMetadata holds details about calls to the UpdateMetadata method.
		UpdateMetadata []struct {
			// Song is the song argument value.
			Song radio.Song
		}
		// UpdateRequestInfo holds details about calls to the UpdateRequestInfo method.
		UpdateRequestInfo []struct {
			// TrackID is the trackID argument value.
			TrackID radio.TrackID
		}
		// UpdateUsable holds details about calls to the UpdateUsable method.
		UpdateUsable []struct {
			// Song is the song argument value.
			Song radio.Song
			// State is the state argument value.
			State radio.TrackState
		}
	}
	lockAll                   sync.RWMutex
	lockBeforeLastRequested   sync.RWMutex
	lockDecrementRequestCount sync.RWMutex
	lockDelete                sync.RWMutex
	lockGet                   sync.RWMutex
	lockInsert                sync.RWMutex
	lockQueueCandidates       sync.RWMutex
	lockUnusable              sync.RWMutex
	lockUpdateLastPlayed      sync.RWMutex
	lockUpdateLastRequested   sync.RWMutex
	lockUpdateMetadata        sync.RWMutex
	lockUpdateRequestInfo     sync.RWMutex
	lockUpdateUsable          sync.RWMutex
}

// All calls AllFunc.
func (mock *TrackStorageMock) All() ([]radio.Song, error) {
	if mock.AllFunc == nil {
		panic("TrackStorageMock.AllFunc: method is nil but TrackStorage.All was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	mock.lockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//
//	len(mockedTrackStorage.AllCalls())
func (mock *TrackStorageMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAll.RLock()
	calls = mock.calls.All
	mock.lockAll.RUnlock()
	return calls
}

// BeforeLastRequested calls BeforeLastRequestedFunc.
func (mock *TrackStorageMock) BeforeLastRequested(before time.Time) ([]radio.Song, error) {
	if mock.BeforeLastRequestedFunc == nil {
		panic("TrackStorageMock.BeforeLastRequestedFunc: method is nil but TrackStorage.BeforeLastRequested was just called")
	}
	callInfo := struct {
		Before time.Time
	}{
		Before: before,
	}
	mock.lockBeforeLastRequested.Lock()
	mock.calls.BeforeLastRequested = append(mock.calls.BeforeLastRequested, callInfo)
	mock.lockBeforeLastRequested.Unlock()
	return mock.BeforeLastRequestedFunc(before)
}

// BeforeLastRequestedCalls gets all the calls that were made to BeforeLastRequested.
// Check the length with:
//
//	len(mockedTrackStorage.BeforeLastRequestedCalls())
func (mock *TrackStorageMock) BeforeLastRequestedCalls() []struct {
	Before time.Time
} {
	var calls []struct {
		Before time.Time
	}
	mock.lockBeforeLastRequested.RLock()
	calls = mock.calls.BeforeLastRequested
	mock.lockBeforeLastRequested.RUnlock()
	return calls
}

// DecrementRequestCount calls DecrementRequestCountFunc.
func (mock *TrackStorageMock) DecrementRequestCount(before time.Time) error {
	if mock.DecrementRequestCountFunc == nil {
		panic("TrackStorageMock.DecrementRequestCountFunc: method is nil but TrackStorage.DecrementRequestCount was just called")
	}
	callInfo := struct {
		Before time.Time
	}{
		Before: before,
	}
	mock.lockDecrementRequestCount.Lock()
	mock.calls.DecrementRequestCount = append(mock.calls.DecrementRequestCount, callInfo)
	mock.lockDecrementRequestCount.Unlock()
	return mock.DecrementRequestCountFunc(before)
}

// DecrementRequestCountCalls gets all the calls that were made to DecrementRequestCount.
// Check the length with:
//
//	len(mockedTrackStorage.DecrementRequestCountCalls())
func (mock *TrackStorageMock) DecrementRequestCountCalls() []struct {
	Before time.Time
} {
	var calls []struct {
		Before time.Time
	}
	mock.lockDecrementRequestCount.RLock()
	calls = mock.calls.DecrementRequestCount
	mock.lockDecrementRequestCount.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *TrackStorageMock) Delete(trackID radio.TrackID) error {
	if mock.DeleteFunc == nil {
		panic("TrackStorageMock.DeleteFunc: method is nil but TrackStorage.Delete was just called")
	}
	callInfo := struct {
		TrackID radio.TrackID
	}{
		TrackID: trackID,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(trackID)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedTrackStorage.DeleteCalls())
func (mock *TrackStorageMock) DeleteCalls() []struct {
	TrackID radio.TrackID
} {
	var calls []struct {
		TrackID radio.TrackID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *TrackStorageMock) Get(trackID radio.TrackID) (*radio.Song, error) {
	if mock.GetFunc == nil {
		panic("TrackStorageMock.GetFunc: method is nil but TrackStorage.Get was just called")
	}
	callInfo := struct {
		TrackID radio.TrackID
	}{
		TrackID: trackID,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(trackID)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedTrackStorage.GetCalls())
func (mock *TrackStorageMock) GetCalls() []struct {
	TrackID radio.TrackID
} {
	var calls []struct {
		TrackID radio.TrackID
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *TrackStorageMock) Insert(song radio.Song) (radio.TrackID, error) {
	if mock.InsertFunc == nil {
		panic("TrackStorageMock.InsertFunc: method is nil but TrackStorage.Insert was just called")
	}
	callInfo := struct {
		Song radio.Song
	}{
		Song: song,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(song)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedTrackStorage.InsertCalls())
func (mock *TrackStorageMock) InsertCalls() []struct {
	Song radio.Song
} {
	var calls []struct {
		Song radio.Song
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}

// QueueCandidates calls QueueCandidatesFunc.
func (mock *TrackStorageMock) QueueCandidates() ([]radio.TrackID, error) {
	if mock.QueueCandidatesFunc == nil {
		panic("TrackStorageMock.QueueCandidatesFunc: method is nil but TrackStorage.QueueCandidates was just called")
	}
	callInfo := struct {
	}{}
	mock.lockQueueCandidates.Lock()
	mock.calls.QueueCandidates = append(mock.calls.QueueCandidates, callInfo)
	mock.lockQueueCandidates.Unlock()
	return mock.QueueCandidatesFunc()
}

// QueueCandidatesCalls gets all the calls that were made to QueueCandidates.
// Check the length with:
//
//	len(mockedTrackStorage.QueueCandidatesCalls())
func (mock *TrackStorageMock) QueueCandidatesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockQueueCandidates.RLock()
	calls = mock.calls.QueueCandidates
	mock.lockQueueCandidates.RUnlock()
	return calls
}

// Unusable calls UnusableFunc.
func (mock *TrackStorageMock) Unusable() ([]radio.Song, error) {
	if mock.UnusableFunc == nil {
		panic("TrackStorageMock.UnusableFunc: method is nil but TrackStorage.Unusable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnusable.Lock()
	mock.calls.Unusable = append(mock.calls.Unusable, callInfo)
	mock.lockUnusable.Unlock()
	return mock.UnusableFunc()
}

// UnusableCalls gets all the calls that were made to Unusable.
// Check the length with:
//
//	len(mockedTrackStorage.UnusableCalls())
func (mock *TrackStorageMock) UnusableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnusable.RLock()
	calls = mock.calls.Unusable
	mock.lockUnusable.RUnlock()
	return calls
}

// UpdateLastPlayed calls UpdateLastPlayedFunc.
func (mock *TrackStorageMock) UpdateLastPlayed(trackID radio.TrackID) error {
	if mock.UpdateLastPlayedFunc == nil {
		panic("TrackStorageMock.UpdateLastPlayedFunc: method is nil but TrackStorage.UpdateLastPlayed was just called")
	}
	callInfo := struct {
		TrackID radio.TrackID
	}{
		TrackID: trackID,
	}
	mock.lockUpdateLastPlayed.Lock()
	mock.calls.UpdateLastPlayed = append(mock.calls.UpdateLastPlayed, callInfo)
	mock.lockUpdateLastPlayed.Unlock()
	return mock.UpdateLastPlayedFunc(trackID)
}

// UpdateLastPlayedCalls gets all the calls that were made to UpdateLastPlayed.
// Check the length with:
//
//	len(mockedTrackStorage.UpdateLastPlayedCalls())
func (mock *TrackStorageMock) UpdateLastPlayedCalls() []struct {
	TrackID radio.TrackID
} {
	var calls []struct {
		TrackID radio.TrackID
	}
	mock.lockUpdateLastPlayed.RLock()
	calls = mock.calls.UpdateLastPlayed
	mock.lockUpdateLastPlayed.RUnlock()
	return calls
}

// UpdateLastRequested calls UpdateLastRequestedFunc.
func (mock *TrackStorageMock) UpdateLastRequested(trackID radio.TrackID) error {
	if mock.UpdateLastRequestedFunc == nil {
		panic("TrackStorageMock.UpdateLastRequestedFunc: method is nil but TrackStorage.UpdateLastRequested was just called")
	}
	callInfo := struct {
		TrackID radio.TrackID
	}{
		TrackID: trackID,
	}
	mock.lockUpdateLastRequested.Lock()
	mock.calls.UpdateLastRequested = append(mock.calls.UpdateLastRequested, callInfo)
	mock.lockUpdateLastRequested.Unlock()
	return mock.UpdateLastRequestedFunc(trackID)
}

// UpdateLastRequestedCalls gets all the calls that were made to UpdateLastRequested.
// Check the length with:
//
//	len(mockedTrackStorage.UpdateLastRequestedCalls())
func (mock *TrackStorageMock) UpdateLastRequestedCalls() []struct {
	TrackID radio.TrackID
} {
	var calls []struct {
		TrackID radio.TrackID
	}
	mock.lockUpdateLastRequested.RLock()
	calls = mock.calls.UpdateLastRequested
	mock.lockUpdateLastRequested.RUnlock()
	return calls
}

// UpdateMetadata calls UpdateMetadataFunc.
func (mock *TrackStorageMock) UpdateMetadata(song radio.Song) error {
	if mock.UpdateMetadataFunc == nil {
		panic("TrackStorageMock.UpdateMetadataFunc: method is nil but TrackStorage.UpdateMetadata was just called")
	}
	callInfo := struct {
		Song radio.Song
	}{
		Song: song,
	}
	mock.lockUpdateMetadata.Lock()
	mock.calls.UpdateMetadata = append(mock.calls.UpdateMetadata, callInfo)
	mock.lockUpdateMetadata.Unlock()
	return mock.UpdateMetadataFunc(song)
}

// UpdateMetadataCalls gets all the calls that were made to UpdateMetadata.
// Check the length with:
//
//	len(mockedTrackStorage.UpdateMetadataCalls())
func (mock *TrackStorageMock) UpdateMetadataCalls() []struct {
	Song radio.Song
} {
	var calls []struct {
		Song radio.Song
	}
	mock.lockUpdateMetadata.RLock()
	calls = mock.calls.UpdateMetadata
	mock.lockUpdateMetadata.RUnlock()
	return calls
}

// UpdateRequestInfo calls UpdateRequestInfoFunc.
func (mock *TrackStorageMock) UpdateRequestInfo(trackID radio.TrackID) error {
	if mock.UpdateRequestInfoFunc == nil {
		panic("TrackStorageMock.UpdateRequestInfoFunc: method is nil but TrackStorage.UpdateRequestInfo was just called")
	}
	callInfo := struct {
		TrackID radio.TrackID
	}{
		TrackID: trackID,
	}
	mock.lockUpdateRequestInfo.Lock()
	mock.calls.UpdateRequestInfo = append(mock.calls.UpdateRequestInfo, callInfo)
	mock.lockUpdateRequestInfo.Unlock()
	return mock.UpdateRequestInfoFunc(trackID)
}

// UpdateRequestInfoCalls gets all the calls that were made to UpdateRequestInfo.
// Check the length with:
//
//	len(mockedTrackStorage.UpdateRequestInfoCalls())
func (mock *TrackStorageMock) UpdateRequestInfoCalls() []struct {
	TrackID radio.TrackID
} {
	var calls []struct {
		TrackID radio.TrackID
	}
	mock.lockUpdateRequestInfo.RLock()
	calls = mock.calls.UpdateRequestInfo
	mock.lockUpdateRequestInfo.RUnlock()
	return calls
}

// UpdateUsable calls UpdateUsableFunc.
func (mock *TrackStorageMock) UpdateUsable(song radio.Song, state radio.TrackState) error {
	if mock.UpdateUsableFunc == nil {
		panic("TrackStorageMock.UpdateUsableFunc: method is nil but TrackStorage.UpdateUsable was just called")
	}
	callInfo := struct {
		Song  radio.Song
		State radio.TrackState
	}{
		Song:  song,
		State: state,
	}
	mock.lockUpdateUsable.Lock()
	mock.calls.UpdateUsable = append(mock.calls.UpdateUsable, callInfo)
	mock.lockUpdateUsable.Unlock()
	return mock.UpdateUsableFunc(song, state)
}

// UpdateUsableCalls gets all the calls that were made to UpdateUsable.
// Check the length with:
//
//	len(mockedTrackStorage.UpdateUsableCalls())
func (mock *TrackStorageMock) UpdateUsableCalls() []struct {
	Song  radio.Song
	State radio.TrackState
} {
	var calls []struct {
		Song  radio.Song
		State radio.TrackState
	}
	mock.lockUpdateUsable.RLock()
	calls = mock.calls.UpdateUsable
	mock.lockUpdateUsable.RUnlock()
	return calls
}

// Ensure, that SubmissionStorageMock does implement radio.SubmissionStorage.
// If this is not the case, regenerate this file with moq.
var _ radio.SubmissionStorage = &SubmissionStorageMock{}

// SubmissionStorageMock is a mock implementation of radio.SubmissionStorage.
//
//	func TestSomethingThatUsesSubmissionStorage(t *testing.T) {
//
//		// make and configure a mocked radio.SubmissionStorage
//		mockedSubmissionStorage := &SubmissionStorageMock{
//			AllFunc: func() ([]radio.PendingSong, error) {
//				panic("mock out the All method")
//			},
//			GetSubmissionFunc: func(submissionID radio.SubmissionID) (*radio.PendingSong, error) {
//				panic("mock out the GetSubmission method")
//			},
//			InsertPostPendingFunc: func(pendingSong radio.PendingSong) error {
//				panic("mock out the InsertPostPending method")
//			},
//			InsertSubmissionFunc: func(pendingSong radio.PendingSong) error {
//				panic("mock out the InsertSubmission method")
//			},
//			LastSubmissionTimeFunc: func(identifier string) (time.Time, error) {
//				panic("mock out the LastSubmissionTime method")
//			},
//			RemoveSubmissionFunc: func(submissionID radio.SubmissionID) error {
//				panic("mock out the RemoveSubmission method")
//			},
//			SubmissionStatsFunc: func(identifier string) (radio.SubmissionStats, error) {
//				panic("mock out the SubmissionStats method")
//			},
//			UpdateSubmissionTimeFunc: func(identifier string) error {
//				panic("mock out the UpdateSubmissionTime method")
//			},
//		}
//
//		// use mockedSubmissionStorage in code that requires radio.SubmissionStorage
//		// and then make assertions.
//
//	}
type SubmissionStorageMock struct {
	// AllFunc mocks the All method.
	AllFunc func() ([]radio.PendingSong, error)

	// GetSubmissionFunc mocks the GetSubmission method.
	GetSubmissionFunc func(submissionID radio.SubmissionID) (*radio.PendingSong, error)

	// InsertPostPendingFunc mocks the InsertPostPending method.
	InsertPostPendingFunc func(pendingSong radio.PendingSong) error

	// InsertSubmissionFunc mocks the InsertSubmission method.
	InsertSubmissionFunc func(pendingSong radio.PendingSong) error

	// LastSubmissionTimeFunc mocks the LastSubmissionTime method.
	LastSubmissionTimeFunc func(identifier string) (time.Time, error)

	// RemoveSubmissionFunc mocks the RemoveSubmission method.
	RemoveSubmissionFunc func(submissionID radio.SubmissionID) error

	// SubmissionStatsFunc mocks the SubmissionStats method.
	SubmissionStatsFunc func(identifier string) (radio.SubmissionStats, error)

	// UpdateSubmissionTimeFunc mocks the UpdateSubmissionTime method.
	UpdateSubmissionTimeFunc func(identifier string) error

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// GetSubmission holds details about calls to the GetSubmission method.
		GetSubmission []struct {
			// SubmissionID is the submissionID argument value.
			SubmissionID radio.SubmissionID
		}
		// InsertPostPending holds details about calls to the InsertPostPending method.
		InsertPostPending []struct {
			// PendingSong is the pendingSong argument value.
			PendingSong radio.PendingSong
		}
		// InsertSubmission holds details about calls to the InsertSubmission method.
		InsertSubmission []struct {
			// PendingSong is the pendingSong argument value.
			PendingSong radio.PendingSong
		}
		// LastSubmissionTime holds details about calls to the LastSubmissionTime method.
		LastSubmissionTime []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
		// RemoveSubmission holds details about calls to the RemoveSubmission method.
		RemoveSubmission []struct {
			// SubmissionID is the submissionID argument value.
			SubmissionID radio.SubmissionID
		}
		// SubmissionStats holds details about calls to the SubmissionStats method.
		SubmissionStats []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
		// UpdateSubmissionTime holds details about calls to the UpdateSubmissionTime method.
		UpdateSubmissionTime []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
	}
	lockAll                  sync.RWMutex
	lockGetSubmission        sync.RWMutex
	lockInsertPostPending    sync.RWMutex
	lockInsertSubmission     sync.RWMutex
	lockLastSubmissionTime   sync.RWMutex
	lockRemoveSubmission     sync.RWMutex
	lockSubmissionStats      sync.RWMutex
	lockUpdateSubmissionTime sync.RWMutex
}

// All calls AllFunc.
func (mock *SubmissionStorageMock) All() ([]radio.PendingSong, error) {
	if mock.AllFunc == nil {
		panic("SubmissionStorageMock.AllFunc: method is nil but SubmissionStorage.All was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	mock.lockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//
//	len(mockedSubmissionStorage.AllCalls())
func (mock *SubmissionStorageMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAll.RLock()
	calls = mock.calls.All
	mock.lockAll.RUnlock()
	return calls
}

// GetSubmission calls GetSubmissionFunc.
func (mock *SubmissionStorageMock) GetSubmission(submissionID radio.SubmissionID) (*radio.PendingSong, error) {
	if mock.GetSubmissionFunc == nil {
		panic("SubmissionStorageMock.GetSubmissionFunc: method is nil but SubmissionStorage.GetSubmission was just called")
	}
	callInfo := struct {
		SubmissionID radio.SubmissionID
	}{
		SubmissionID: submissionID,
	}
	mock.lockGetSubmission.Lock()
	mock.calls.GetSubmission = append(mock.calls.GetSubmission, callInfo)
	mock.lockGetSubmission.Unlock()
	return mock.GetSubmissionFunc(submissionID)
}

// GetSubmissionCalls gets all the calls that were made to GetSubmission.
// Check the length with:
//
//	len(mockedSubmissionStorage.GetSubmissionCalls())
func (mock *SubmissionStorageMock) GetSubmissionCalls() []struct {
	SubmissionID radio.SubmissionID
} {
	var calls []struct {
		SubmissionID radio.SubmissionID
	}
	mock.lockGetSubmission.RLock()
	calls = mock.calls.GetSubmission
	mock.lockGetSubmission.RUnlock()
	return calls
}

// InsertPostPending calls InsertPostPendingFunc.
func (mock *SubmissionStorageMock) InsertPostPending(pendingSong radio.PendingSong) error {
	if mock.InsertPostPendingFunc == nil {
		panic("SubmissionStorageMock.InsertPostPendingFunc: method is nil but SubmissionStorage.InsertPostPending was just called")
	}
	callInfo := struct {
		PendingSong radio.PendingSong
	}{
		PendingSong: pendingSong,
	}
	mock.lockInsertPostPending.Lock()
	mock.calls.InsertPostPending = append(mock.calls.InsertPostPending, callInfo)
	mock.lockInsertPostPending.Unlock()
	return mock.InsertPostPendingFunc(pendingSong)
}

// InsertPostPendingCalls gets all the calls that were made to InsertPostPending.
// Check the length with:
//
//	len(mockedSubmissionStorage.InsertPostPendingCalls())
func (mock *SubmissionStorageMock) InsertPostPendingCalls() []struct {
	PendingSong radio.PendingSong
} {
	var calls []struct {
		PendingSong radio.PendingSong
	}
	mock.lockInsertPostPending.RLock()
	calls = mock.calls.InsertPostPending
	mock.lockInsertPostPending.RUnlock()
	return calls
}

// InsertSubmission calls InsertSubmissionFunc.
func (mock *SubmissionStorageMock) InsertSubmission(pendingSong radio.PendingSong) error {
	if mock.InsertSubmissionFunc == nil {
		panic("SubmissionStorageMock.InsertSubmissionFunc: method is nil but SubmissionStorage.InsertSubmission was just called")
	}
	callInfo := struct {
		PendingSong radio.PendingSong
	}{
		PendingSong: pendingSong,
	}
	mock.lockInsertSubmission.Lock()
	mock.calls.InsertSubmission = append(mock.calls.InsertSubmission, callInfo)
	mock.lockInsertSubmission.Unlock()
	return mock.InsertSubmissionFunc(pendingSong)
}

// InsertSubmissionCalls gets all the calls that were made to InsertSubmission.
// Check the length with:
//
//	len(mockedSubmissionStorage.InsertSubmissionCalls())
func (mock *SubmissionStorageMock) InsertSubmissionCalls() []struct {
	PendingSong radio.PendingSong
} {
	var calls []struct {
		PendingSong radio.PendingSong
	}
	mock.lockInsertSubmission.RLock()
	calls = mock.calls.InsertSubmission
	mock.lockInsertSubmission.RUnlock()
	return calls
}

// LastSubmissionTime calls LastSubmissionTimeFunc.
func (mock *SubmissionStorageMock) LastSubmissionTime(identifier string) (time.Time, error) {
	if mock.LastSubmissionTimeFunc == nil {
		panic("SubmissionStorageMock.LastSubmissionTimeFunc: method is nil but SubmissionStorage.LastSubmissionTime was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockLastSubmissionTime.Lock()
	mock.calls.LastSubmissionTime = append(mock.calls.LastSubmissionTime, callInfo)
	mock.lockLastSubmissionTime.Unlock()
	return mock.LastSubmissionTimeFunc(identifier)
}

// LastSubmissionTimeCalls gets all the calls that were made to LastSubmissionTime.
// Check the length with:
//
//	len(mockedSubmissionStorage.LastSubmissionTimeCalls())
func (mock *SubmissionStorageMock) LastSubmissionTimeCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockLastSubmissionTime.RLock()
	calls = mock.calls.LastSubmissionTime
	mock.lockLastSubmissionTime.RUnlock()
	return calls
}

// RemoveSubmission calls RemoveSubmissionFunc.
func (mock *SubmissionStorageMock) RemoveSubmission(submissionID radio.SubmissionID) error {
	if mock.RemoveSubmissionFunc == nil {
		panic("SubmissionStorageMock.RemoveSubmissionFunc: method is nil but SubmissionStorage.RemoveSubmission was just called")
	}
	callInfo := struct {
		SubmissionID radio.SubmissionID
	}{
		SubmissionID: submissionID,
	}
	mock.lockRemoveSubmission.Lock()
	mock.calls.RemoveSubmission = append(mock.calls.RemoveSubmission, callInfo)
	mock.lockRemoveSubmission.Unlock()
	return mock.RemoveSubmissionFunc(submissionID)
}

// RemoveSubmissionCalls gets all the calls that were made to RemoveSubmission.
// Check the length with:
//
//	len(mockedSubmissionStorage.RemoveSubmissionCalls())
func (mock *SubmissionStorageMock) RemoveSubmissionCalls() []struct {
	SubmissionID radio.SubmissionID
} {
	var calls []struct {
		SubmissionID radio.SubmissionID
	}
	mock.lockRemoveSubmission.RLock()
	calls = mock.calls.RemoveSubmission
	mock.lockRemoveSubmission.RUnlock()
	return calls
}

// SubmissionStats calls SubmissionStatsFunc.
func (mock *SubmissionStorageMock) SubmissionStats(identifier string) (radio.SubmissionStats, error) {
	if mock.SubmissionStatsFunc == nil {
		panic("SubmissionStorageMock.SubmissionStatsFunc: method is nil but SubmissionStorage.SubmissionStats was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockSubmissionStats.Lock()
	mock.calls.SubmissionStats = append(mock.calls.SubmissionStats, callInfo)
	mock.lockSubmissionStats.Unlock()
	return mock.SubmissionStatsFunc(identifier)
}

// SubmissionStatsCalls gets all the calls that were made to SubmissionStats.
// Check the length with:
//
//	len(mockedSubmissionStorage.SubmissionStatsCalls())
func (mock *SubmissionStorageMock) SubmissionStatsCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockSubmissionStats.RLock()
	calls = mock.calls.SubmissionStats
	mock.lockSubmissionStats.RUnlock()
	return calls
}

// UpdateSubmissionTime calls UpdateSubmissionTimeFunc.
func (mock *SubmissionStorageMock) UpdateSubmissionTime(identifier string) error {
	if mock.UpdateSubmissionTimeFunc == nil {
		panic("SubmissionStorageMock.UpdateSubmissionTimeFunc: method is nil but SubmissionStorage.UpdateSubmissionTime was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockUpdateSubmissionTime.Lock()
	mock.calls.UpdateSubmissionTime = append(mock.calls.UpdateSubmissionTime, callInfo)
	mock.lockUpdateSubmissionTime.Unlock()
	return mock.UpdateSubmissionTimeFunc(identifier)
}

// UpdateSubmissionTimeCalls gets all the calls that were made to UpdateSubmissionTime.
// Check the length with:
//
//	len(mockedSubmissionStorage.UpdateSubmissionTimeCalls())
func (mock *SubmissionStorageMock) UpdateSubmissionTimeCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockUpdateSubmissionTime.RLock()
	calls = mock.calls.UpdateSubmissionTime
	mock.lockUpdateSubmissionTime.RUnlock()
	return calls
}

// Ensure, that UserStorageMock does implement radio.UserStorage.
// If this is not the case, regenerate this file with moq.
var _ radio.UserStorage = &UserStorageMock{}

// UserStorageMock is a mock implementation of radio.UserStorage.
//
//	func TestSomethingThatUsesUserStorage(t *testing.T) {
//
//		// make and configure a mocked radio.UserStorage
//		mockedUserStorage := &UserStorageMock{
//			AllFunc: func() ([]radio.User, error) {
//				panic("mock out the All method")
//			},
//			ByNickFunc: func(nick string) (*radio.User, error) {
//				panic("mock out the ByNick method")
//			},
//			CreateFunc: func(user radio.User) (radio.UserID, error) {
//				panic("mock out the Create method")
//			},
//			CreateDJFunc: func(user radio.User, dJ radio.DJ) (radio.DJID, error) {
//				panic("mock out the CreateDJ method")
//			},
//			GetFunc: func(name string) (*radio.User, error) {
//				panic("mock out the Get method")
//			},
//			GetByDJIDFunc: func(dJID radio.DJID) (*radio.User, error) {
//				panic("mock out the GetByDJID method")
//			},
//			GetByIDFunc: func(userID radio.UserID) (*radio.User, error) {
//				panic("mock out the GetByID method")
//			},
//			LookupNameFunc: func(name string) (*radio.User, error) {
//				panic("mock out the LookupName method")
//			},
//			PermissionsFunc: func() ([]radio.UserPermission, error) {
//				panic("mock out the Permissions method")
//			},
//			RecordListenersFunc: func(n int64, user radio.User) error {
//				panic("mock out the RecordListeners method")
//			},
//			UpdateFunc: func(user radio.User) (radio.User, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedUserStorage in code that requires radio.UserStorage
//		// and then make assertions.
//
//	}
type UserStorageMock struct {
	// AllFunc mocks the All method.
	AllFunc func() ([]radio.User, error)

	// ByNickFunc mocks the ByNick method.
	ByNickFunc func(nick string) (*radio.User, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(user radio.User) (radio.UserID, error)

	// CreateDJFunc mocks the CreateDJ method.
	CreateDJFunc func(user radio.User, dJ radio.DJ) (radio.DJID, error)

	// GetFunc mocks the Get method.
	GetFunc func(name string) (*radio.User, error)

	// GetByDJIDFunc mocks the GetByDJID method.
	GetByDJIDFunc func(dJID radio.DJID) (*radio.User, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(userID radio.UserID) (*radio.User, error)

	// LookupNameFunc mocks the LookupName method.
	LookupNameFunc func(name string) (*radio.User, error)

	// PermissionsFunc mocks the Permissions method.
	PermissionsFunc func() ([]radio.UserPermission, error)

	// RecordListenersFunc mocks the RecordListeners method.
	RecordListenersFunc func(n int64, user radio.User) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(user radio.User) (radio.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// ByNick holds details about calls to the ByNick method.
		ByNick []struct {
			// Nick is the nick argument value.
			Nick string
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// User is the user argument value.
			User radio.User
		}
		// CreateDJ holds details about calls to the CreateDJ method.
		CreateDJ []struct {
			// User is the user argument value.
			User radio.User
			// DJ is the dJ argument value.
			DJ radio.DJ
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Name is the name argument value.
			Name string
		}
		// GetByDJID holds details about calls to the GetByDJID method.
		GetByDJID []struct {
			// DJID is the dJID argument value.
			DJID radio.DJID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// UserID is the userID argument value.
			UserID radio.UserID
		}
		// LookupName holds details about calls to the LookupName method.
		LookupName []struct {
			// Name is the name argument value.
			Name string
		}
		// Permissions holds details about calls to the Permissions method.
		Permissions []struct {
		}
		// RecordListeners holds details about calls to the RecordListeners method.
		RecordListeners []struct {
			// N is the n argument value.
			N int64
			// User is the user argument value.
			User radio.User
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// User is the user argument value.
			User radio.User
		}
	}
	lockAll             sync.RWMutex
	lockByNick          sync.RWMutex
	lockCreate          sync.RWMutex
	lockCreateDJ        sync.RWMutex
	lockGet             sync.RWMutex
	lockGetByDJID       sync.RWMutex
	lockGetByID         sync.RWMutex
	lockLookupName      sync.RWMutex
	lockPermissions     sync.RWMutex
	lockRecordListeners sync.RWMutex
	lockUpdate          sync.RWMutex
}

// All calls AllFunc.
func (mock *UserStorageMock) All() ([]radio.User, error) {
	if mock.AllFunc == nil {
		panic("UserStorageMock.AllFunc: method is nil but UserStorage.All was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	mock.lockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//
//	len(mockedUserStorage.AllCalls())
func (mock *UserStorageMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAll.RLock()
	calls = mock.calls.All
	mock.lockAll.RUnlock()
	return calls
}

// ByNick calls ByNickFunc.
func (mock *UserStorageMock) ByNick(nick string) (*radio.User, error) {
	if mock.ByNickFunc == nil {
		panic("UserStorageMock.ByNickFunc: method is nil but UserStorage.ByNick was just called")
	}
	callInfo := struct {
		Nick string
	}{
		Nick: nick,
	}
	mock.lockByNick.Lock()
	mock.calls.ByNick = append(mock.calls.ByNick, callInfo)
	mock.lockByNick.Unlock()
	return mock.ByNickFunc(nick)
}

// ByNickCalls gets all the calls that were made to ByNick.
// Check the length with:
//
//	len(mockedUserStorage.ByNickCalls())
func (mock *UserStorageMock) ByNickCalls() []struct {
	Nick string
} {
	var calls []struct {
		Nick string
	}
	mock.lockByNick.RLock()
	calls = mock.calls.ByNick
	mock.lockByNick.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *UserStorageMock) Create(user radio.User) (radio.UserID, error) {
	if mock.CreateFunc == nil {
		panic("UserStorageMock.CreateFunc: method is nil but UserStorage.Create was just called")
	}
	callInfo := struct {
		User radio.User
	}{
		User: user,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(user)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUserStorage.CreateCalls())
func (mock *UserStorageMock) CreateCalls() []struct {
	User radio.User
} {
	var calls []struct {
		User radio.User
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// CreateDJ calls CreateDJFunc.
func (mock *UserStorageMock) CreateDJ(user radio.User, dJ radio.DJ) (radio.DJID, error) {
	if mock.CreateDJFunc == nil {
		panic("UserStorageMock.CreateDJFunc: method is nil but UserStorage.CreateDJ was just called")
	}
	callInfo := struct {
		User radio.User
		DJ   radio.DJ
	}{
		User: user,
		DJ:   dJ,
	}
	mock.lockCreateDJ.Lock()
	mock.calls.CreateDJ = append(mock.calls.CreateDJ, callInfo)
	mock.lockCreateDJ.Unlock()
	return mock.CreateDJFunc(user, dJ)
}

// CreateDJCalls gets all the calls that were made to CreateDJ.
// Check the length with:
//
//	len(mockedUserStorage.CreateDJCalls())
func (mock *UserStorageMock) CreateDJCalls() []struct {
	User radio.User
	DJ   radio.DJ
} {
	var calls []struct {
		User radio.User
		DJ   radio.DJ
	}
	mock.lockCreateDJ.RLock()
	calls = mock.calls.CreateDJ
	mock.lockCreateDJ.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *UserStorageMock) Get(name string) (*radio.User, error) {
	if mock.GetFunc == nil {
		panic("UserStorageMock.GetFunc: method is nil but UserStorage.Get was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(name)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedUserStorage.GetCalls())
func (mock *UserStorageMock) GetCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByDJID calls GetByDJIDFunc.
func (mock *UserStorageMock) GetByDJID(dJID radio.DJID) (*radio.User, error) {
	if mock.GetByDJIDFunc == nil {
		panic("UserStorageMock.GetByDJIDFunc: method is nil but UserStorage.GetByDJID was just called")
	}
	callInfo := struct {
		DJID radio.DJID
	}{
		DJID: dJID,
	}
	mock.lockGetByDJID.Lock()
	mock.calls.GetByDJID = append(mock.calls.GetByDJID, callInfo)
	mock.lockGetByDJID.Unlock()
	return mock.GetByDJIDFunc(dJID)
}

// GetByDJIDCalls gets all the calls that were made to GetByDJID.
// Check the length with:
//
//	len(mockedUserStorage.GetByDJIDCalls())
func (mock *UserStorageMock) GetByDJIDCalls() []struct {
	DJID radio.DJID
} {
	var calls []struct {
		DJID radio.DJID
	}
	mock.lockGetByDJID.RLock()
	calls = mock.calls.GetByDJID
	mock.lockGetByDJID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *UserStorageMock) GetByID(userID radio.UserID) (*radio.User, error) {
	if mock.GetByIDFunc == nil {
		panic("UserStorageMock.GetByIDFunc: method is nil but UserStorage.GetByID was just called")
	}
	callInfo := struct {
		UserID radio.UserID
	}{
		UserID: userID,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(userID)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedUserStorage.GetByIDCalls())
func (mock *UserStorageMock) GetByIDCalls() []struct {
	UserID radio.UserID
} {
	var calls []struct {
		UserID radio.UserID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// LookupName calls LookupNameFunc.
func (mock *UserStorageMock) LookupName(name string) (*radio.User, error) {
	if mock.LookupNameFunc == nil {
		panic("UserStorageMock.LookupNameFunc: method is nil but UserStorage.LookupName was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockLookupName.Lock()
	mock.calls.LookupName = append(mock.calls.LookupName, callInfo)
	mock.lockLookupName.Unlock()
	return mock.LookupNameFunc(name)
}

// LookupNameCalls gets all the calls that were made to LookupName.
// Check the length with:
//
//	len(mockedUserStorage.LookupNameCalls())
func (mock *UserStorageMock) LookupNameCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockLookupName.RLock()
	calls = mock.calls.LookupName
	mock.lockLookupName.RUnlock()
	return calls
}

// Permissions calls PermissionsFunc.
func (mock *UserStorageMock) Permissions() ([]radio.UserPermission, error) {
	if mock.PermissionsFunc == nil {
		panic("UserStorageMock.PermissionsFunc: method is nil but UserStorage.Permissions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPermissions.Lock()
	mock.calls.Permissions = append(mock.calls.Permissions, callInfo)
	mock.lockPermissions.Unlock()
	return mock.PermissionsFunc()
}

// PermissionsCalls gets all the calls that were made to Permissions.
// Check the length with:
//
//	len(mockedUserStorage.PermissionsCalls())
func (mock *UserStorageMock) PermissionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPermissions.RLock()
	calls = mock.calls.Permissions
	mock.lockPermissions.RUnlock()
	return calls
}

// RecordListeners calls RecordListenersFunc.
func (mock *UserStorageMock) RecordListeners(n int64, user radio.User) error {
	if mock.RecordListenersFunc == nil {
		panic("UserStorageMock.RecordListenersFunc: method is nil but UserStorage.RecordListeners was just called")
	}
	callInfo := struct {
		N    int64
		User radio.User
	}{
		N:    n,
		User: user,
	}
	mock.lockRecordListeners.Lock()
	mock.calls.RecordListeners = append(mock.calls.RecordListeners, callInfo)
	mock.lockRecordListeners.Unlock()
	return mock.RecordListenersFunc(n, user)
}

// RecordListenersCalls gets all the calls that were made to RecordListeners.
// Check the length with:
//
//	len(mockedUserStorage.RecordListenersCalls())
func (mock *UserStorageMock) RecordListenersCalls() []struct {
	N    int64
	User radio.User
} {
	var calls []struct {
		N    int64
		User radio.User
	}
	mock.lockRecordListeners.RLock()
	calls = mock.calls.RecordListeners
	mock.lockRecordListeners.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *UserStorageMock) Update(user radio.User) (radio.User, error) {
	if mock.UpdateFunc == nil {
		panic("UserStorageMock.UpdateFunc: method is nil but UserStorage.Update was just called")
	}
	callInfo := struct {
		User radio.User
	}{
		User: user,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(user)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedUserStorage.UpdateCalls())
func (mock *UserStorageMock) UpdateCalls() []struct {
	User radio.User
} {
	var calls []struct {
		User radio.User
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ManagerServiceMock does implement radio.ManagerService.
// If this is not the case, regenerate this file with moq.
var _ radio.ManagerService = &ManagerServiceMock{}

// ManagerServiceMock is a mock implementation of radio.ManagerService.
//
//	func TestSomethingThatUsesManagerService(t *testing.T) {
//
//		// make and configure a mocked radio.ManagerService
//		mockedManagerService := &ManagerServiceMock{
//			CurrentListenersFunc: func(contextMoqParam context.Context) (eventstream.Stream[int64], error) {
//				panic("mock out the CurrentListeners method")
//			},
//			CurrentSongFunc: func(contextMoqParam context.Context) (eventstream.Stream[*radio.SongUpdate], error) {
//				panic("mock out the CurrentSong method")
//			},
//			CurrentStatusFunc: func(contextMoqParam context.Context) (eventstream.Stream[radio.Status], error) {
//				panic("mock out the CurrentStatus method")
//			},
//			CurrentThreadFunc: func(contextMoqParam context.Context) (eventstream.Stream[string], error) {
//				panic("mock out the CurrentThread method")
//			},
//			CurrentUserFunc: func(contextMoqParam context.Context) (eventstream.Stream[*radio.User], error) {
//				panic("mock out the CurrentUser method")
//			},
//			UpdateListenersFunc: func(contextMoqParam context.Context, n int64) error {
//				panic("mock out the UpdateListeners method")
//			},
//			UpdateSongFunc: func(contextMoqParam context.Context, songUpdate *radio.SongUpdate) error {
//				panic("mock out the UpdateSong method")
//			},
//			UpdateThreadFunc: func(contextMoqParam context.Context, s string) error {
//				panic("mock out the UpdateThread method")
//			},
//			UpdateUserFunc: func(contextMoqParam context.Context, user *radio.User) error {
//				panic("mock out the UpdateUser method")
//			},
//		}
//
//		// use mockedManagerService in code that requires radio.ManagerService
//		// and then make assertions.
//
//	}
type ManagerServiceMock struct {
	// CurrentListenersFunc mocks the CurrentListeners method.
	CurrentListenersFunc func(contextMoqParam context.Context) (eventstream.Stream[int64], error)

	// CurrentSongFunc mocks the CurrentSong method.
	CurrentSongFunc func(contextMoqParam context.Context) (eventstream.Stream[*radio.SongUpdate], error)

	// CurrentStatusFunc mocks the CurrentStatus method.
	CurrentStatusFunc func(contextMoqParam context.Context) (eventstream.Stream[radio.Status], error)

	// CurrentThreadFunc mocks the CurrentThread method.
	CurrentThreadFunc func(contextMoqParam context.Context) (eventstream.Stream[string], error)

	// CurrentUserFunc mocks the CurrentUser method.
	CurrentUserFunc func(contextMoqParam context.Context) (eventstream.Stream[*radio.User], error)

	// UpdateListenersFunc mocks the UpdateListeners method.
	UpdateListenersFunc func(contextMoqParam context.Context, n int64) error

	// UpdateSongFunc mocks the UpdateSong method.
	UpdateSongFunc func(contextMoqParam context.Context, songUpdate *radio.SongUpdate) error

	// UpdateThreadFunc mocks the UpdateThread method.
	UpdateThreadFunc func(contextMoqParam context.Context, s string) error

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(contextMoqParam context.Context, user *radio.User) error

	// calls tracks calls to the methods.
	calls struct {
		// CurrentListeners holds details about calls to the CurrentListeners method.
		CurrentListeners []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// CurrentSong holds details about calls to the CurrentSong method.
		CurrentSong []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// CurrentStatus holds details about calls to the CurrentStatus method.
		CurrentStatus []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// CurrentThread holds details about calls to the CurrentThread method.
		CurrentThread []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// CurrentUser holds details about calls to the CurrentUser method.
		CurrentUser []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// UpdateListeners holds details about calls to the UpdateListeners method.
		UpdateListeners []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// N is the n argument value.
			N int64
		}
		// UpdateSong holds details about calls to the UpdateSong method.
		UpdateSong []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SongUpdate is the songUpdate argument value.
			SongUpdate *radio.SongUpdate
		}
		// UpdateThread holds details about calls to the UpdateThread method.
		UpdateThread []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// S is the s argument value.
			S string
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// User is the user argument value.
			User *radio.User
		}
	}
	lockCurrentListeners sync.RWMutex
	lockCurrentSong      sync.RWMutex
	lockCurrentStatus    sync.RWMutex
	lockCurrentThread    sync.RWMutex
	lockCurrentUser      sync.RWMutex
	lockUpdateListeners  sync.RWMutex
	lockUpdateSong       sync.RWMutex
	lockUpdateThread     sync.RWMutex
	lockUpdateUser       sync.RWMutex
}

// CurrentListeners calls CurrentListenersFunc.
func (mock *ManagerServiceMock) CurrentListeners(contextMoqParam context.Context) (eventstream.Stream[int64], error) {
	if mock.CurrentListenersFunc == nil {
		panic("ManagerServiceMock.CurrentListenersFunc: method is nil but ManagerService.CurrentListeners was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockCurrentListeners.Lock()
	mock.calls.CurrentListeners = append(mock.calls.CurrentListeners, callInfo)
	mock.lockCurrentListeners.Unlock()
	return mock.CurrentListenersFunc(contextMoqParam)
}

// CurrentListenersCalls gets all the calls that were made to CurrentListeners.
// Check the length with:
//
//	len(mockedManagerService.CurrentListenersCalls())
func (mock *ManagerServiceMock) CurrentListenersCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockCurrentListeners.RLock()
	calls = mock.calls.CurrentListeners
	mock.lockCurrentListeners.RUnlock()
	return calls
}

// CurrentSong calls CurrentSongFunc.
func (mock *ManagerServiceMock) CurrentSong(contextMoqParam context.Context) (eventstream.Stream[*radio.SongUpdate], error) {
	if mock.CurrentSongFunc == nil {
		panic("ManagerServiceMock.CurrentSongFunc: method is nil but ManagerService.CurrentSong was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockCurrentSong.Lock()
	mock.calls.CurrentSong = append(mock.calls.CurrentSong, callInfo)
	mock.lockCurrentSong.Unlock()
	return mock.CurrentSongFunc(contextMoqParam)
}

// CurrentSongCalls gets all the calls that were made to CurrentSong.
// Check the length with:
//
//	len(mockedManagerService.CurrentSongCalls())
func (mock *ManagerServiceMock) CurrentSongCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockCurrentSong.RLock()
	calls = mock.calls.CurrentSong
	mock.lockCurrentSong.RUnlock()
	return calls
}

// CurrentStatus calls CurrentStatusFunc.
func (mock *ManagerServiceMock) CurrentStatus(contextMoqParam context.Context) (eventstream.Stream[radio.Status], error) {
	if mock.CurrentStatusFunc == nil {
		panic("ManagerServiceMock.CurrentStatusFunc: method is nil but ManagerService.CurrentStatus was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockCurrentStatus.Lock()
	mock.calls.CurrentStatus = append(mock.calls.CurrentStatus, callInfo)
	mock.lockCurrentStatus.Unlock()
	return mock.CurrentStatusFunc(contextMoqParam)
}

// CurrentStatusCalls gets all the calls that were made to CurrentStatus.
// Check the length with:
//
//	len(mockedManagerService.CurrentStatusCalls())
func (mock *ManagerServiceMock) CurrentStatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockCurrentStatus.RLock()
	calls = mock.calls.CurrentStatus
	mock.lockCurrentStatus.RUnlock()
	return calls
}

// CurrentThread calls CurrentThreadFunc.
func (mock *ManagerServiceMock) CurrentThread(contextMoqParam context.Context) (eventstream.Stream[string], error) {
	if mock.CurrentThreadFunc == nil {
		panic("ManagerServiceMock.CurrentThreadFunc: method is nil but ManagerService.CurrentThread was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockCurrentThread.Lock()
	mock.calls.CurrentThread = append(mock.calls.CurrentThread, callInfo)
	mock.lockCurrentThread.Unlock()
	return mock.CurrentThreadFunc(contextMoqParam)
}

// CurrentThreadCalls gets all the calls that were made to CurrentThread.
// Check the length with:
//
//	len(mockedManagerService.CurrentThreadCalls())
func (mock *ManagerServiceMock) CurrentThreadCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockCurrentThread.RLock()
	calls = mock.calls.CurrentThread
	mock.lockCurrentThread.RUnlock()
	return calls
}

// CurrentUser calls CurrentUserFunc.
func (mock *ManagerServiceMock) CurrentUser(contextMoqParam context.Context) (eventstream.Stream[*radio.User], error) {
	if mock.CurrentUserFunc == nil {
		panic("ManagerServiceMock.CurrentUserFunc: method is nil but ManagerService.CurrentUser was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockCurrentUser.Lock()
	mock.calls.CurrentUser = append(mock.calls.CurrentUser, callInfo)
	mock.lockCurrentUser.Unlock()
	return mock.CurrentUserFunc(contextMoqParam)
}

// CurrentUserCalls gets all the calls that were made to CurrentUser.
// Check the length with:
//
//	len(mockedManagerService.CurrentUserCalls())
func (mock *ManagerServiceMock) CurrentUserCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockCurrentUser.RLock()
	calls = mock.calls.CurrentUser
	mock.lockCurrentUser.RUnlock()
	return calls
}

// UpdateListeners calls UpdateListenersFunc.
func (mock *ManagerServiceMock) UpdateListeners(contextMoqParam context.Context, n int64) error {
	if mock.UpdateListenersFunc == nil {
		panic("ManagerServiceMock.UpdateListenersFunc: method is nil but ManagerService.UpdateListeners was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		N               int64
	}{
		ContextMoqParam: contextMoqParam,
		N:               n,
	}
	mock.lockUpdateListeners.Lock()
	mock.calls.UpdateListeners = append(mock.calls.UpdateListeners, callInfo)
	mock.lockUpdateListeners.Unlock()
	return mock.UpdateListenersFunc(contextMoqParam, n)
}

// UpdateListenersCalls gets all the calls that were made to UpdateListeners.
// Check the length with:
//
//	len(mockedManagerService.UpdateListenersCalls())
func (mock *ManagerServiceMock) UpdateListenersCalls() []struct {
	ContextMoqParam context.Context
	N               int64
} {
	var calls []struct {
		ContextMoqParam context.Context
		N               int64
	}
	mock.lockUpdateListeners.RLock()
	calls = mock.calls.UpdateListeners
	mock.lockUpdateListeners.RUnlock()
	return calls
}

// UpdateSong calls UpdateSongFunc.
func (mock *ManagerServiceMock) UpdateSong(contextMoqParam context.Context, songUpdate *radio.SongUpdate) error {
	if mock.UpdateSongFunc == nil {
		panic("ManagerServiceMock.UpdateSongFunc: method is nil but ManagerService.UpdateSong was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SongUpdate      *radio.SongUpdate
	}{
		ContextMoqParam: contextMoqParam,
		SongUpdate:      songUpdate,
	}
	mock.lockUpdateSong.Lock()
	mock.calls.UpdateSong = append(mock.calls.UpdateSong, callInfo)
	mock.lockUpdateSong.Unlock()
	return mock.UpdateSongFunc(contextMoqParam, songUpdate)
}

// UpdateSongCalls gets all the calls that were made to UpdateSong.
// Check the length with:
//
//	len(mockedManagerService.UpdateSongCalls())
func (mock *ManagerServiceMock) UpdateSongCalls() []struct {
	ContextMoqParam context.Context
	SongUpdate      *radio.SongUpdate
} {
	var calls []struct {
		ContextMoqParam context.Context
		SongUpdate      *radio.SongUpdate
	}
	mock.lockUpdateSong.RLock()
	calls = mock.calls.UpdateSong
	mock.lockUpdateSong.RUnlock()
	return calls
}

// UpdateThread calls UpdateThreadFunc.
func (mock *ManagerServiceMock) UpdateThread(contextMoqParam context.Context, s string) error {
	if mock.UpdateThreadFunc == nil {
		panic("ManagerServiceMock.UpdateThreadFunc: method is nil but ManagerService.UpdateThread was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		S               string
	}{
		ContextMoqParam: contextMoqParam,
		S:               s,
	}
	mock.lockUpdateThread.Lock()
	mock.calls.UpdateThread = append(mock.calls.UpdateThread, callInfo)
	mock.lockUpdateThread.Unlock()
	return mock.UpdateThreadFunc(contextMoqParam, s)
}

// UpdateThreadCalls gets all the calls that were made to UpdateThread.
// Check the length with:
//
//	len(mockedManagerService.UpdateThreadCalls())
func (mock *ManagerServiceMock) UpdateThreadCalls() []struct {
	ContextMoqParam context.Context
	S               string
} {
	var calls []struct {
		ContextMoqParam context.Context
		S               string
	}
	mock.lockUpdateThread.RLock()
	calls = mock.calls.UpdateThread
	mock.lockUpdateThread.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *ManagerServiceMock) UpdateUser(contextMoqParam context.Context, user *radio.User) error {
	if mock.UpdateUserFunc == nil {
		panic("ManagerServiceMock.UpdateUserFunc: method is nil but ManagerService.UpdateUser was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		User            *radio.User
	}{
		ContextMoqParam: contextMoqParam,
		User:            user,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(contextMoqParam, user)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockedManagerService.UpdateUserCalls())
func (mock *ManagerServiceMock) UpdateUserCalls() []struct {
	ContextMoqParam context.Context
	User            *radio.User
} {
	var calls []struct {
		ContextMoqParam context.Context
		User            *radio.User
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// Ensure, that SearchServiceMock does implement radio.SearchService.
// If this is not the case, regenerate this file with moq.
var _ radio.SearchService = &SearchServiceMock{}

// SearchServiceMock is a mock implementation of radio.SearchService.
//
//	func TestSomethingThatUsesSearchService(t *testing.T) {
//
//		// make and configure a mocked radio.SearchService
//		mockedSearchService := &SearchServiceMock{
//			DeleteFunc: func(contextMoqParam context.Context, trackIDs ...radio.TrackID) error {
//				panic("mock out the Delete method")
//			},
//			SearchFunc: func(ctx context.Context, query string, limit int64, offset int64) (*radio.SearchResult, error) {
//				panic("mock out the Search method")
//			},
//			UpdateFunc: func(contextMoqParam context.Context, songs ...radio.Song) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedSearchService in code that requires radio.SearchService
//		// and then make assertions.
//
//	}
type SearchServiceMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(contextMoqParam context.Context, trackIDs ...radio.TrackID) error

	// SearchFunc mocks the Search method.
	SearchFunc func(ctx context.Context, query string, limit int64, offset int64) (*radio.SearchResult, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(contextMoqParam context.Context, songs ...radio.Song) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// TrackIDs is the trackIDs argument value.
			TrackIDs []radio.TrackID
		}
		// Search holds details about calls to the Search method.
		Search []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Limit is the limit argument value.
			Limit int64
			// Offset is the offset argument value.
			Offset int64
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Songs is the songs argument value.
			Songs []radio.Song
		}
	}
	lockDelete sync.RWMutex
	lockSearch sync.RWMutex
	lockUpdate sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *SearchServiceMock) Delete(contextMoqParam context.Context, trackIDs ...radio.TrackID) error {
	if mock.DeleteFunc == nil {
		panic("SearchServiceMock.DeleteFunc: method is nil but SearchService.Delete was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		TrackIDs        []radio.TrackID
	}{
		ContextMoqParam: contextMoqParam,
		TrackIDs:        trackIDs,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(contextMoqParam, trackIDs...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedSearchService.DeleteCalls())
func (mock *SearchServiceMock) DeleteCalls() []struct {
	ContextMoqParam context.Context
	TrackIDs        []radio.TrackID
} {
	var calls []struct {
		ContextMoqParam context.Context
		TrackIDs        []radio.TrackID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Search calls SearchFunc.
func (mock *SearchServiceMock) Search(ctx context.Context, query string, limit int64, offset int64) (*radio.SearchResult, error) {
	if mock.SearchFunc == nil {
		panic("SearchServiceMock.SearchFunc: method is nil but SearchService.Search was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Query  string
		Limit  int64
		Offset int64
	}{
		Ctx:    ctx,
		Query:  query,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockSearch.Lock()
	mock.calls.Search = append(mock.calls.Search, callInfo)
	mock.lockSearch.Unlock()
	return mock.SearchFunc(ctx, query, limit, offset)
}

// SearchCalls gets all the calls that were made to Search.
// Check the length with:
//
//	len(mockedSearchService.SearchCalls())
func (mock *SearchServiceMock) SearchCalls() []struct {
	Ctx    context.Context
	Query  string
	Limit  int64
	Offset int64
} {
	var calls []struct {
		Ctx    context.Context
		Query  string
		Limit  int64
		Offset int64
	}
	mock.lockSearch.RLock()
	calls = mock.calls.Search
	mock.lockSearch.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *SearchServiceMock) Update(contextMoqParam context.Context, songs ...radio.Song) error {
	if mock.UpdateFunc == nil {
		panic("SearchServiceMock.UpdateFunc: method is nil but SearchService.Update was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Songs           []radio.Song
	}{
		ContextMoqParam: contextMoqParam,
		Songs:           songs,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(contextMoqParam, songs...)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedSearchService.UpdateCalls())
func (mock *SearchServiceMock) UpdateCalls() []struct {
	ContextMoqParam context.Context
	Songs           []radio.Song
} {
	var calls []struct {
		ContextMoqParam context.Context
		Songs           []radio.Song
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that RequestStorageMock does implement radio.RequestStorage.
// If this is not the case, regenerate this file with moq.
var _ radio.RequestStorage = &RequestStorageMock{}

// RequestStorageMock is a mock implementation of radio.RequestStorage.
//
//	func TestSomethingThatUsesRequestStorage(t *testing.T) {
//
//		// make and configure a mocked radio.RequestStorage
//		mockedRequestStorage := &RequestStorageMock{
//			LastRequestFunc: func(identifier string) (time.Time, error) {
//				panic("mock out the LastRequest method")
//			},
//			UpdateLastRequestFunc: func(identifier string) error {
//				panic("mock out the UpdateLastRequest method")
//			},
//		}
//
//		// use mockedRequestStorage in code that requires radio.RequestStorage
//		// and then make assertions.
//
//	}
type RequestStorageMock struct {
	// LastRequestFunc mocks the LastRequest method.
	LastRequestFunc func(identifier string) (time.Time, error)

	// UpdateLastRequestFunc mocks the UpdateLastRequest method.
	UpdateLastRequestFunc func(identifier string) error

	// calls tracks calls to the methods.
	calls struct {
		// LastRequest holds details about calls to the LastRequest method.
		LastRequest []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
		// UpdateLastRequest holds details about calls to the UpdateLastRequest method.
		UpdateLastRequest []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
	}
	lockLastRequest       sync.RWMutex
	lockUpdateLastRequest sync.RWMutex
}

// LastRequest calls LastRequestFunc.
func (mock *RequestStorageMock) LastRequest(identifier string) (time.Time, error) {
	if mock.LastRequestFunc == nil {
		panic("RequestStorageMock.LastRequestFunc: method is nil but RequestStorage.LastRequest was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockLastRequest.Lock()
	mock.calls.LastRequest = append(mock.calls.LastRequest, callInfo)
	mock.lockLastRequest.Unlock()
	return mock.LastRequestFunc(identifier)
}

// LastRequestCalls gets all the calls that were made to LastRequest.
// Check the length with:
//
//	len(mockedRequestStorage.LastRequestCalls())
func (mock *RequestStorageMock) LastRequestCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockLastRequest.RLock()
	calls = mock.calls.LastRequest
	mock.lockLastRequest.RUnlock()
	return calls
}

// UpdateLastRequest calls UpdateLastRequestFunc.
func (mock *RequestStorageMock) UpdateLastRequest(identifier string) error {
	if mock.UpdateLastRequestFunc == nil {
		panic("RequestStorageMock.UpdateLastRequestFunc: method is nil but RequestStorage.UpdateLastRequest was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockUpdateLastRequest.Lock()
	mock.calls.UpdateLastRequest = append(mock.calls.UpdateLastRequest, callInfo)
	mock.lockUpdateLastRequest.Unlock()
	return mock.UpdateLastRequestFunc(identifier)
}

// UpdateLastRequestCalls gets all the calls that were made to UpdateLastRequest.
// Check the length with:
//
//	len(mockedRequestStorage.UpdateLastRequestCalls())
func (mock *RequestStorageMock) UpdateLastRequestCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockUpdateLastRequest.RLock()
	calls = mock.calls.UpdateLastRequest
	mock.lockUpdateLastRequest.RUnlock()
	return calls
}
