package storagetest

import (
	"reflect"
	"time"

	radio "github.com/R-a-dio/valkyrie"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/arbitrary"
	"github.com/leanovate/gopter/gen"
)

// OneOff generates a single value from the gopter.Gen given
func OneOff[T any](gen gopter.Gen) T {
	const maxOneOffTries = 100

	pars := gopter.DefaultGenParameters()
	var res *gopter.GenResult

	for i := 0; i < maxOneOffTries; i++ {
		res = gen(pars)
		if res.Result != nil {
			break
		}
	}
	if res.Result == nil {
		panic("didn't get a non-nil value from gopter.Gen after max tries")
	}

	return res.Result.(T)
}

func LimitString(size int) func(string) bool {
	return func(s string) bool {
		return len(s) < size
	}
}

func genUser() gopter.Gen {
	arbitraries := arbitrary.DefaultArbitraries()

	return gen.Struct(reflect.TypeOf(radio.User{}), map[string]gopter.Gen{
		"ID":              arbitraries.GenForType(reflect.TypeOf(radio.UserID(0))),
		"Username":        gen.AlphaString().SuchThat(LimitString(50)),
		"Password":        gen.AlphaString().SuchThat(LimitString(120)),
		"Email":           gen.RegexMatch(`\w+@\w+\.\w{2,25}`).SuchThat(LimitString(255)),
		"IP":              gen.RegexMatch(`\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}`),
		"UpdatedAt":       genTimePtr(),
		"CreatedAt":       genTime(),
		"UserPermissions": genUserPermissions(),
	})
}

// generates a radio.UserPermissions with random permissions generated by genUserPermission
func genUserPermissions() gopter.Gen {
	g := gen.MapOf(genUserPermission(), gen.Bool())
	return gopter.Gen(func(gp *gopter.GenParameters) *gopter.GenResult {
		res := g(gp)
		actual := make(map[radio.UserPermission]struct{})
		m := res.Result.(map[radio.UserPermission]bool)
		for perm, ok := range m {
			if ok {
				actual[perm] = struct{}{}
			}
		}
		res.Result = actual
		res.ResultType = reflect.TypeOf(res.Result)
		return res
	}).WithShrinker(nil)
}

// generates one of the radio.UserPermission
func genUserPermission() gopter.Gen {
	all := radio.AllUserPermissions()
	in := make([]any, len(all))
	for i := 0; i < len(all); i++ {
		in[i] = all[i]
	}
	return gen.OneConstOf(in...)
}

func genTime() gopter.Gen {
	return gen.TimeRange(ourStartTime, time.Hour*24*3500).WithShrinker(nil)
}

// genTimePtr is genTime but returning *time.Time
func genTimePtr() gopter.Gen {
	g := gen.TimeRange(ourStartTime, time.Hour*24*3500).WithShrinker(nil)
	return func(gp *gopter.GenParameters) *gopter.GenResult {
		res := g(gp)
		t := res.Result.(time.Time)
		res.Result = &t
		res.ResultType = reflect.TypeOf(res.Result)
		return res
	}
}
